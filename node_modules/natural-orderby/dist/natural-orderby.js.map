{"version":3,"file":"natural-orderby.js","sources":["../src/utils/compareNumbers.js","../src/utils/regex.js","../src/utils/compareUnicode.js","../src/utils/stringCompare.js","../src/utils/compareChunks.js","../src/utils/compareOtherTypes.js","../src/utils/compareValues.js","../src/utils/compareMultiple.js","../src/utils/createIdentifierFn.js","../src/utils/stringify.js","../src/utils/parseNumber.js","../src/utils/parseDate.js","../src/utils/numberify.js","../src/utils/createChunks.js","../src/utils/normalizeChunk.js","../src/utils/createChunksList.js","../src/utils/isFunction.js","../src/utils/isNaN.js","../src/utils/isNull.js","../src/utils/isObject.js","../src/utils/isSymbol.js","../src/utils/isUndefined.js","../src/utils/getMappedValueRecord.js","../src/utils/getValueByIdentifier.js","../src/utils/getElementByIndex.js","../src/utils/baseOrderBy.js","../src/utils/getIdentifiers.js","../src/utils/getOrders.js","../src/orderBy/index.js","../src/utils/baseCompare.js","../src/utils/getOptions.js","../src/compare/index.js"],"sourcesContent":["// @flow\nconst compareNumbers = (numberA: number, numberB: number): number => {\n  if (numberA < numberB) {\n    return -1;\n  }\n  if (numberA > numberB) {\n    return 1;\n  }\n  return 0;\n};\n\nexport default compareNumbers;\n","// @flow\nconst RE_NUMBERS = /(^0x[\\da-fA-F]+$|^([+-]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:[eE][+-]?\\d+)?(?!\\.\\d+)(?=\\D|\\s|$))|\\d+)/g;\nconst RE_LEADING_OR_TRAILING_WHITESPACES = /^\\s+|\\s+$/g; // trim pre-post whitespace\nconst RE_WHITESPACES = /\\s+/g; // normalize all whitespace to single ' ' character\nconst RE_INT_OR_FLOAT = /^[+-]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:[eE][+-]?\\d+)?$/; // identify integers and floats\nconst RE_DATE = /(^([\\w ]+,?[\\w ]+)?[\\w ]+,?[\\w ]+\\d+:\\d+(:\\d+)?[\\w ]?|^\\d{1,4}[/-]\\d{1,4}[/-]\\d{1,4}|^\\w+, \\w+ \\d+, \\d{4})/; // identify date strings\nconst RE_LEADING_ZERO = /^0+[1-9]{1}[0-9]*$/;\nconst RE_UNICODE_CHARACTERS = /[^\\x00-\\x80]/;\n\nexport {\n  RE_NUMBERS,\n  RE_LEADING_OR_TRAILING_WHITESPACES,\n  RE_WHITESPACES,\n  RE_INT_OR_FLOAT,\n  RE_DATE,\n  RE_LEADING_ZERO,\n  RE_UNICODE_CHARACTERS,\n};\n","// @flow\nconst compareUnicode = (stringA: string, stringB: string): number => {\n  const result = stringA.localeCompare(stringB);\n  return result ? result / Math.abs(result) : 0;\n};\n\nexport default compareUnicode;\n","// @flow\nconst stringCompare = (stringA: string, stringB: string): number => {\n  if (stringA < stringB) {\n    return -1;\n  }\n  if (stringA > stringB) {\n    return 1;\n  }\n  return 0;\n};\n\nexport default stringCompare;\n","// @flow\nimport type { Chunks } from '../types';\nimport { RE_UNICODE_CHARACTERS } from './regex';\nimport compareNumbers from './compareNumbers';\nimport compareUnicode from './compareUnicode';\nimport stringCompare from './stringCompare';\n\nconst compareChunks = (chunksA: Chunks, chunksB: Chunks): number => {\n  const lengthA = chunksA.length;\n  const lengthB = chunksB.length;\n  const size = Math.min(lengthA, lengthB);\n  for (let i = 0; i < size; i++) {\n    const chunkA = chunksA[i];\n    const chunkB = chunksB[i];\n    if (chunkA !== chunkB) {\n      if ((chunkA === '') !== (chunkB === '')) {\n        // empty strings have lowest value\n        return chunkA === '' ? -1 : 1;\n      }\n      if (typeof chunkA === 'number' && typeof chunkB === 'number') {\n        // compare numbers\n        return compareNumbers(chunkA, chunkB);\n      } else if (typeof chunkA === 'number' || typeof chunkB === 'number') {\n        // number < string\n        return typeof chunkA === 'number' ? -1 : 1;\n      } else if (\n        RE_UNICODE_CHARACTERS.test(chunkA + chunkB) &&\n        chunkA.localeCompare\n      ) {\n        // use locale comparison only if one of the chunks contains unicode characters\n        return compareUnicode(chunkA, chunkB);\n      } else {\n        // use common string comparison for performance reason\n        return stringCompare(chunkA, chunkB);\n      }\n    }\n  }\n  // if the chunks are equal so far, the one which has more chunks is greater than the other one\n  if (lengthA > size || lengthB > size) {\n    return lengthA <= size ? -1 : 1;\n  }\n  return 0;\n};\n\nexport default compareChunks;\n","// @flow\nimport type { MappedValueRecord } from '../types';\n\nconst compareOtherTypes = (\n  valueA: MappedValueRecord,\n  valueB: MappedValueRecord\n): number => {\n  if (!valueA.chunks ? valueB.chunks : !valueB.chunks) {\n    return !valueA.chunks ? 1 : -1;\n  }\n  if (valueA.isNaN ? !valueB.isNaN : valueB.isNaN) {\n    return valueA.isNaN ? -1 : 1;\n  }\n  if (valueA.isSymbol ? !valueB.isSymbol : valueB.isSymbol) {\n    return valueA.isSymbol ? -1 : 1;\n  }\n  if (valueA.isObject ? !valueB.isObject : valueB.isObject) {\n    return valueA.isObject ? -1 : 1;\n  }\n  if (valueA.isArray ? !valueB.isArray : valueB.isArray) {\n    return valueA.isArray ? -1 : 1;\n  }\n  if (valueA.isFunction ? !valueB.isFunction : valueB.isFunction) {\n    return valueA.isFunction ? -1 : 1;\n  }\n  if (valueA.isNull ? !valueB.isNull : valueB.isNull) {\n    return valueA.isNull ? -1 : 1;\n  }\n  return 0;\n};\n\nexport default compareOtherTypes;\n","// @flow\nimport type { MappedValueRecord } from '../types';\nimport compareNumbers from './compareNumbers';\nimport compareChunks from './compareChunks';\nimport compareOtherTypes from './compareOtherTypes';\n\nconst compareValues = (\n  valueA: MappedValueRecord,\n  valueB: MappedValueRecord\n): number => {\n  if (valueA.value === valueB.value) {\n    return 0;\n  }\n  if (valueA.parsedNumber !== undefined && valueB.parsedNumber !== undefined) {\n    return compareNumbers(valueA.parsedNumber, valueB.parsedNumber);\n  }\n  if (valueA.chunks && valueB.chunks) {\n    return compareChunks(valueA.chunks, valueB.chunks);\n  }\n  return compareOtherTypes(valueA, valueB);\n};\n\nexport default compareValues;\n","// @flow\nimport type { Order, MappedRecord } from '../types';\nimport compareValues from './compareValues';\n\nconst compareMultiple = (\n  recordA: MappedRecord,\n  recordB: MappedRecord,\n  orders: $ReadOnlyArray<Order>\n): number => {\n  const { values: valuesA } = recordA;\n  const { values: valuesB } = recordB;\n  const { length } = valuesA;\n  const ordersLength = orders.length;\n  for (let i = 0; i < length; i++) {\n    const order = i < ordersLength ? orders[i] : null;\n    if (order && typeof order === 'function') {\n      const result = order(valuesA[i].value, valuesB[i].value);\n      if (result) {\n        return result;\n      }\n    } else {\n      const result = compareValues(valuesA[i], valuesB[i]);\n      if (result) {\n        return result * (order === 'desc' ? -1 : 1);\n      }\n    }\n  }\n  return 0;\n};\n\nexport default compareMultiple;\n","// @flow\nimport type { Identifier, IdentifierFn } from '../types';\n\nconst createIdentifierFn = <T>(identifier: Identifier<T>): IdentifierFn<T> => {\n  if (typeof identifier === 'function') {\n    // identifier is already a lookup function\n    return identifier;\n  }\n  return (value: T): mixed => {\n    if (Array.isArray(value)) {\n      const index = Number(identifier);\n      if (Number.isInteger(index)) {\n        return value[index];\n      }\n    } else if (\n      value &&\n      typeof value === 'object' &&\n      typeof identifier !== 'function'\n    ) {\n      return value[identifier];\n    }\n    return value;\n  };\n};\n\nexport default createIdentifierFn;\n","// @flow\nimport { RE_LEADING_OR_TRAILING_WHITESPACES } from './regex';\nimport type { CaseSensitive } from '../types';\n\nconst stringify = (\n  value: string | number | boolean | Boolean | Number | String | Date | any,\n  caseSensitive: CaseSensitive\n): string => {\n  if (typeof value === 'boolean' || value instanceof Boolean) {\n    return Number(value).toString();\n  }\n  if (typeof value === 'number' || value instanceof Number) {\n    return value.toString();\n  }\n  if (value instanceof Date) {\n    return value.getTime().toString();\n  }\n  if (typeof value === 'string' || value instanceof String) {\n    return (caseSensitive ? value : value.toLowerCase()).replace(\n      RE_LEADING_OR_TRAILING_WHITESPACES,\n      ''\n    );\n  }\n  return '';\n};\n\nexport default stringify;\n","// @flow\nimport type { ParsedNumber } from '../types';\n\nconst parseNumber = (value: string): ParsedNumber | void => {\n  if (value.length !== 0) {\n    const parsedNumber = Number(value);\n    if (!Number.isNaN(parsedNumber)) {\n      return parsedNumber;\n    }\n  }\n  return undefined;\n};\n\nexport default parseNumber;\n","// @flow\nimport type { ParsedNumber } from '../types';\nimport { RE_DATE } from './regex';\n\nconst parseDate = (value: string): ParsedNumber | void => {\n  if (RE_DATE.test(value)) {\n    const parsedDate = Date.parse(value);\n    if (!Number.isNaN(parsedDate)) {\n      return parsedDate;\n    }\n  }\n  return undefined;\n};\n\nexport default parseDate;\n","// @flow\nimport parseNumber from './parseNumber';\nimport parseDate from './parseDate';\nimport type { ParsedNumber } from '../types';\n\nconst numberify = (value: string): ParsedNumber | void => {\n  const parsedNumber = parseNumber(value);\n  if (parsedNumber !== undefined) {\n    return parsedNumber;\n  }\n  return parseDate(value);\n};\n\nexport default numberify;\n","// @flow\nimport { RE_NUMBERS } from './regex';\n\nconst createChunks = (value: string): Array<string> =>\n  value\n    .replace(RE_NUMBERS, '\\0$1\\0')\n    .replace(/\\0$/, '')\n    .replace(/^\\0/, '')\n    .split('\\0');\n\nexport default createChunks;\n","// @flow\nimport type { Chunk } from '../types';\nimport {\n  RE_LEADING_OR_TRAILING_WHITESPACES,\n  RE_WHITESPACES,\n  RE_INT_OR_FLOAT,\n  RE_LEADING_ZERO,\n} from './regex';\nimport parseNumber from './parseNumber';\n\nconst normalizeChunk = (chunk: string, chunksLength: number): Chunk => {\n  if (\n    RE_INT_OR_FLOAT.test(chunk) &&\n    (!RE_LEADING_ZERO.test(chunk) || chunksLength === 1)\n  ) {\n    return parseNumber(chunk) || 0;\n  }\n  return chunk\n    .replace(RE_WHITESPACES, ' ')\n    .replace(RE_LEADING_OR_TRAILING_WHITESPACES, '');\n};\n\nexport default normalizeChunk;\n","// @flow\nimport type { Chunks } from '../types';\nimport createChunks from './createChunks';\nimport normalizeChunk from './normalizeChunk';\n\nconst createChunksList = (value: string): Chunks => {\n  const chunks = createChunks(value).map((chunk, index, array) =>\n    normalizeChunk(chunk, array.length)\n  );\n  return chunks;\n};\n\nexport default createChunksList;\n","// @flow\nconst isFunction = (value: mixed): boolean => typeof value === 'function';\n\nexport default isFunction;\n","// @flow\nconst isNaN = (value: mixed): boolean =>\n  Number.isNaN(value) ||\n  (value instanceof Number && Number.isNaN(value.valueOf()));\n\nexport default isNaN;\n","// @flow\nconst isNull = (value: mixed): boolean => value === null;\n\nexport default isNull;\n","// @flow\nconst isObject = (value: mixed): boolean =>\n  value !== null &&\n  typeof value === 'object' &&\n  !Array.isArray(value) &&\n  !(value instanceof Number) &&\n  !(value instanceof String) &&\n  !(value instanceof Boolean) &&\n  !(value instanceof Date);\n\nexport default isObject;\n","// @flow\nconst isSymbol = (value: mixed): boolean => typeof value === 'symbol';\n\nexport default isSymbol;\n","// @flow\nconst isUndefined = (value: mixed): boolean => value === undefined;\n\nexport default isUndefined;\n","// @flow\nimport type { CaseSensitive, MappedValueRecord } from '../types';\nimport stringify from './stringify';\nimport numberify from './numberify';\nimport createChunksList from './createChunksList';\nimport isFunction from './isFunction';\nimport isNaN from './isNaN';\nimport isNull from './isNull';\nimport isObject from './isObject';\nimport isSymbol from './isSymbol';\nimport isUndefined from './isUndefined';\n\nconst getMappedValueRecord = (caseSensitive: CaseSensitive = true) => (\n  value: mixed\n): MappedValueRecord => {\n  if (\n    typeof value === 'string' ||\n    value instanceof String ||\n    ((typeof value === 'number' || value instanceof Number) && !isNaN(value)) ||\n    typeof value === 'boolean' ||\n    value instanceof Boolean ||\n    value instanceof Date\n  ) {\n    const stringValue = stringify(value, caseSensitive);\n    const parsedNumber = numberify(stringValue);\n    const chunks = createChunksList(\n      parsedNumber ? `${parsedNumber}` : stringValue\n    );\n    return {\n      parsedNumber,\n      chunks,\n      value,\n    };\n  }\n  return {\n    isArray: Array.isArray(value),\n    isFunction: isFunction(value),\n    isNaN: isNaN(value),\n    isNull: isNull(value),\n    isObject: isObject(value),\n    isSymbol: isSymbol(value),\n    isUndefined: isUndefined(value),\n    value,\n  };\n};\n\nexport default getMappedValueRecord;\n","// @flow\nimport type { IdentifierFn } from '../types';\n\nconst getValueByIdentifier = <T>(\n  value: T,\n  getValue: IdentifierFn<T>\n): mixed | T => getValue(value);\n\nexport default getValueByIdentifier;\n","// @flow\nconst getElementByIndex = <T>(\n  collection: $ReadOnlyArray<T>,\n  index: number\n): T => collection[index];\n\nexport default getElementByIndex;\n","// @flow\nimport compareMultiple from './compareMultiple';\nimport createIdentifierFn from './createIdentifierFn';\nimport getMappedValueRecord from './getMappedValueRecord';\nimport getValueByIdentifier from './getValueByIdentifier';\nimport getElementByIndex from './getElementByIndex';\n\nimport type {\n  Identifier,\n  Order,\n  MappedCollection,\n  IdentifierFn,\n} from '../types';\n\nconst baseOrderBy = <T>(\n  collection: $ReadOnlyArray<T>,\n  identifiers: $ReadOnlyArray<Identifier<T>>,\n  orders: $ReadOnlyArray<Order>\n): Array<T> => {\n  const identifierFns: Array<IdentifierFn<T>> = identifiers.length\n    ? identifiers.map(createIdentifierFn)\n    : [(value: T): T => value];\n\n  // temporary array holds elements with position and sort-values\n  const mappedCollection: MappedCollection = collection.map(\n    (element, index) => {\n      const values = identifierFns\n        .map(identifier => getValueByIdentifier(element, identifier))\n        .map(getMappedValueRecord());\n      return {\n        index,\n        values,\n      };\n    }\n  );\n\n  // iterate over values and compare values until a != b or last value reached\n  mappedCollection.sort((recordA, recordB) =>\n    compareMultiple(recordA, recordB, orders)\n  );\n\n  return mappedCollection.map(element =>\n    getElementByIndex(collection, element.index)\n  );\n};\n\nexport default baseOrderBy;\n","// @flow\nimport type { Identifier } from '../types';\n\nconst getIdentifiers = <T>(\n  identifiers?: ?$ReadOnlyArray<Identifier<T>> | ?Identifier<T>\n): Array<Identifier<T>> => {\n  if (!identifiers) {\n    return [];\n  }\n  const identifierList = !Array.isArray(identifiers)\n    ? [identifiers]\n    : [...identifiers];\n  if (\n    identifierList.some(\n      identifier =>\n        typeof identifier !== 'string' &&\n        typeof identifier !== 'number' &&\n        typeof identifier !== 'function'\n    )\n  ) {\n    return [];\n  }\n  return identifierList;\n};\n\nexport default getIdentifiers;\n","// @flow\nimport type { Order } from '../types';\n\nconst getOrders = (orders?: ?$ReadOnlyArray<Order> | ?Order): Array<Order> => {\n  if (!orders) {\n    return [];\n  }\n  const orderList = !Array.isArray(orders) ? [orders] : [...orders];\n  if (\n    orderList.some(\n      order =>\n        order !== 'asc' && order !== 'desc' && typeof order !== 'function'\n    )\n  ) {\n    return [];\n  }\n  return (orderList: Array<Order>);\n};\n\nexport default getOrders;\n","// @flow\nimport baseOrderBy from '../utils/baseOrderBy';\nimport getIdentifiers from '../utils/getIdentifiers';\nimport getOrders from '../utils/getOrders';\n\nimport type { Identifier, Order } from '../types';\n\n/**\n * Creates an array of elements, natural sorted by specified identifiers and\n * the corresponding sort orders. This method implements a stable sort\n * algorithm, which means the original sort order of equal elements is\n * preserved.\n *\n * If `collection` is an array of primitives, `identifiers` may be unspecified.\n * Otherwise, you should specify `identifiers` to sort by or `collection` will\n * be returned unsorted. An identifier can expressed by:\n *\n * - an index position, if `collection` is a nested array,\n * - a property name, if `collection` is an array of objects,\n * - a function which returns a particular value from an element of a nested array or an array of objects. This function will be invoked by passing one element of `collection`.\n *\n * If `orders` is unspecified, all values are sorted in ascending order.\n * Otherwise, specify an order of `'desc'` for descending or `'asc'` for\n * ascending sort order of corresponding values. You may also specify a compare\n * function for an order, which will be invoked by two arguments:\n * `(valueA, valueB)`. It must return a number representing the sort order.\n *\n * @example\n *\n * import { orderBy } from 'natural-orderby';\n *\n * const users = [\n *   {\n *     username: 'Bamm-Bamm',\n *     ip: '192.168.5.2',\n *     datetime: 'Fri Jun 15 2018 16:48:00 GMT+0200 (CEST)'\n *   },\n *   {\n *     username: 'Wilma',\n *     ip: '192.168.10.1',\n *     datetime: '14 Jun 2018 00:00:00 PDT'\n *   },\n *   {\n *     username: 'dino',\n *     ip: '192.168.0.2',\n *     datetime: 'June 15, 2018 14:48:00'\n *   },\n *   {\n *     username: 'Barney',\n *     ip: '192.168.1.1',\n *     datetime: 'Thu, 14 Jun 2018 07:00:00 GMT'\n *   },\n *   {\n *     username: 'Pebbles',\n *     ip: '192.168.1.21',\n *     datetime: '15 June 2018 14:48 UTC'\n *   },\n *   {\n *     username: 'Hoppy',\n *     ip: '192.168.5.10',\n *     datetime: '2018-06-15T14:48:00.000Z'\n *   },\n * ];\n *\n * orderBy(\n *   users,\n *   [v => v.datetime, v => v.ip],\n *   ['desc', 'asc']\n * );\n *\n * // => [\n * //      {\n * //        username: 'dino',\n * //        ip: '192.168.0.2',\n * //        datetime: 'June 15, 2018 14:48:00',\n * //      },\n * //      {\n * //        username: 'Pebbles',\n * //        ip: '192.168.1.21',\n * //        datetime: '15 June 2018 14:48 UTC',\n * //      },\n * //      {\n * //        username: 'Bamm-Bamm',\n * //        ip: '192.168.5.2',\n * //        datetime: 'Fri Jun 15 2018 16:48:00 GMT+0200 (CEST)',\n * //      },\n * //      {\n * //        username: 'Hoppy',\n * //        ip: '192.168.5.10',\n * //        datetime: '2018-06-15T14:48:00.000Z',\n * //      },\n * //      {\n * //        username: 'Barney',\n * //        ip: '192.168.1.1',\n * //        datetime: 'Thu, 14 Jun 2018 07:00:00 GMT',\n * //      },\n * //      {\n * //        username: 'Wilma',\n * //        ip: '192.168.10.1',\n * //        datetime: '14 Jun 2018 00:00:00 PDT',\n * //      },\n * //    ]\n */\nfunction orderBy<T>(\n  collection: $ReadOnlyArray<T>,\n  identifiers?: ?$ReadOnlyArray<Identifier<T>> | ?Identifier<T>,\n  orders?: ?$ReadOnlyArray<Order> | ?Order\n): Array<T> {\n  if (!collection || !Array.isArray(collection)) {\n    return [];\n  }\n\n  const validatedIdentifiers = getIdentifiers(identifiers);\n  const validatedOrders = getOrders(orders);\n\n  return baseOrderBy(collection, validatedIdentifiers, validatedOrders);\n}\n\nexport default orderBy;\n","// @flow\nimport configureGetMappedValueRecord from './getMappedValueRecord';\nimport compareValues from './compareValues';\n\nimport type { BaseCompareOptions } from '../types';\n\nconst baseCompare = (options: BaseCompareOptions) => (\n  valueA: mixed,\n  valueB: mixed\n): number => {\n  const getMappedValueRecord = configureGetMappedValueRecord(\n    options.caseSensitive\n  );\n  const a = getMappedValueRecord(valueA);\n  const b = getMappedValueRecord(valueB);\n\n  const result = compareValues(a, b);\n  return result * (options.order === 'desc' ? -1 : 1);\n};\n\nexport default baseCompare;\n","// @flow\nimport type { CompareOptions, BaseCompareOptions } from '../types';\n\nconst defaultOptions: BaseCompareOptions = {\n  caseSensitive: true,\n  order: 'asc',\n};\n\nconst getOptions = (customOptions?: CompareOptions): BaseCompareOptions => {\n  if (!customOptions || typeof customOptions !== 'object') {\n    return defaultOptions;\n  }\n  return {\n    caseSensitive:\n      typeof customOptions.caseSensitive === 'boolean'\n        ? customOptions.caseSensitive\n        : defaultOptions.caseSensitive,\n    order:\n      customOptions.order === 'asc' || customOptions.order === 'desc'\n        ? customOptions.order\n        : defaultOptions.order,\n  };\n};\n\nexport default getOptions;\n","// @flow\nimport baseCompare from '../utils/baseCompare';\nimport getOptions from '../utils/getOptions';\n\nimport type { CompareOptions, CompareFn } from '../types';\n\n/**\n * Creates a compare function that defines the natural sort order considering\n * the given `options` which may be passed to [`Array.prototype.sort()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort).\n *\n * If `options` or its property `caseSensitive` is unspecified, values are\n * sorted case sensitive. Otherwise, specify `true` for case sensitive or\n * `false` for case insensitive sorting.\n *\n * If `options` or its property `order` is unspecified, values are sorted in\n * ascending sort order. Otherwise, specify an order of `'desc'` for descending\n * or `'asc'` for ascending sort order of values.\n *\n * @example\n *\n * import { compare } from 'natural-orderby';\n *\n * const users = [\n *   {\n *     username: 'Bamm-Bamm',\n *     lastLogin: {\n *       ip: '192.168.5.2',\n *       datetime: 'Fri Jun 15 2018 16:48:00 GMT+0200 (CEST)'\n *     },\n *   },\n *   {\n *     username: 'Wilma',\n *     lastLogin: {\n *       ip: '192.168.10.1',\n *       datetime: '14 Jun 2018 00:00:00 PDT'\n *     },\n *   },\n *   {\n *     username: 'dino',\n *     lastLogin: {\n *       ip: '192.168.0.2',\n *       datetime: 'June 15, 2018 14:48:00'\n *     },\n *   },\n *   {\n *     username: 'Barney',\n *     lastLogin: {\n *       ip: '192.168.1.1',\n *       datetime: 'Thu, 14 Jun 2018 07:00:00 GMT'\n *     },\n *   },\n *   {\n *     username: 'Pebbles',\n *     lastLogin: {\n *       ip: '192.168.1.21',\n *       datetime: '15 June 2018 14:48 UTC'\n *     },\n *   },\n *   {\n *     username: 'Hoppy',\n *     lastLogin: {\n *       ip: '192.168.5.10',\n *       datetime: '2018-06-15T14:48:00.000Z'\n *     },\n *   },\n * ];\n *\n * users.sort((a, b) => compare()(a.ip, b.ip));\n *\n * // => [\n * //      {\n * //        username: 'dino',\n * //        ip: '192.168.0.2',\n * //        datetime: 'June 15, 2018 14:48:00'\n * //      },\n * //      {\n * //        username: 'Barney',\n * //        ip: '192.168.1.1',\n * //        datetime: 'Thu, 14 Jun 2018 07:00:00 GMT'\n * //      },\n * //      {\n * //        username: 'Pebbles',\n * //        ip: '192.168.1.21',\n * //        datetime: '15 June 2018 14:48 UTC'\n * //      },\n * //      {\n * //        username: 'Bamm-Bamm',\n * //        ip: '192.168.5.2',\n * //        datetime: 'Fri Jun 15 2018 16:48:00 GMT+0200 (CEST)'\n * //      },\n * //      {\n * //        username: 'Hoppy',\n * //        ip: '192.168.5.10',\n * //        datetime: '2018-06-15T14:48:00.000Z'\n * //      },\n * //      {\n * //        username: 'Wilma',\n * //        ip: '192.168.10.1',\n * //        datetime: '14 Jun 2018 00:00:00 PDT'\n * //      }\n * //    ]\n */\nfunction compare(options?: CompareOptions): CompareFn {\n  const validatedOptions = getOptions(options);\n\n  return baseCompare(validatedOptions);\n}\n\nexport default compare;\n"],"names":["compareNumbers","numberA","numberB","RE_NUMBERS","RE_LEADING_OR_TRAILING_WHITESPACES","RE_WHITESPACES","RE_INT_OR_FLOAT","RE_DATE","RE_LEADING_ZERO","RE_UNICODE_CHARACTERS","compareUnicode","stringA","stringB","result","localeCompare","Math","abs","stringCompare","compareChunks","chunksA","chunksB","lengthA","length","lengthB","size","min","i","chunkA","chunkB","test","compareOtherTypes","valueA","valueB","chunks","isNaN","isSymbol","isObject","isArray","isFunction","isNull","compareValues","value","parsedNumber","undefined","compareMultiple","recordA","recordB","orders","valuesA","values","valuesB","ordersLength","order","createIdentifierFn","identifier","Array","index","Number","isInteger","stringify","caseSensitive","Boolean","toString","Date","getTime","String","toLowerCase","replace","parseNumber","parseDate","parsedDate","parse","numberify","createChunks","split","normalizeChunk","chunk","chunksLength","createChunksList","map","array","valueOf","isUndefined","getMappedValueRecord","stringValue","getValueByIdentifier","getValue","getElementByIndex","collection","baseOrderBy","identifiers","identifierFns","mappedCollection","element","sort","getIdentifiers","identifierList","some","getOrders","orderList","orderBy","validatedIdentifiers","validatedOrders","baseCompare","options","configureGetMappedValueRecord","a","b","defaultOptions","getOptions","customOptions","compare","validatedOptions"],"mappings":"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"}