{"version":3,"file":"natural-orderby.es.min.js","sources":["../src/utils/compareNumbers.js","../src/utils/regex.js","../src/utils/compareUnicode.js","../src/utils/stringCompare.js","../src/utils/compareChunks.js","../src/utils/compareOtherTypes.js","../src/utils/compareValues.js","../src/utils/compareMultiple.js","../src/utils/createIdentifierFn.js","../src/utils/stringify.js","../src/utils/parseNumber.js","../src/utils/parseDate.js","../src/utils/numberify.js","../src/utils/createChunks.js","../src/utils/normalizeChunk.js","../src/utils/createChunksList.js","../src/utils/isFunction.js","../src/utils/isNaN.js","../src/utils/isNull.js","../src/utils/isObject.js","../src/utils/isSymbol.js","../src/utils/isUndefined.js","../src/utils/getMappedValueRecord.js","../src/utils/getValueByIdentifier.js","../src/utils/getElementByIndex.js","../src/utils/baseOrderBy.js","../src/utils/getIdentifiers.js","../src/utils/getOrders.js","../src/orderBy/index.js","../src/utils/baseCompare.js","../src/utils/getOptions.js","../src/compare/index.js"],"sourcesContent":["// @flow\nconst compareNumbers = (numberA: number, numberB: number): number => {\n  if (numberA < numberB) {\n    return -1;\n  }\n  if (numberA > numberB) {\n    return 1;\n  }\n  return 0;\n};\n\nexport default compareNumbers;\n","// @flow\nconst RE_NUMBERS = /(^0x[\\da-fA-F]+$|^([+-]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:[eE][+-]?\\d+)?(?!\\.\\d+)(?=\\D|\\s|$))|\\d+)/g;\nconst RE_LEADING_OR_TRAILING_WHITESPACES = /^\\s+|\\s+$/g; // trim pre-post whitespace\nconst RE_WHITESPACES = /\\s+/g; // normalize all whitespace to single ' ' character\nconst RE_INT_OR_FLOAT = /^[+-]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:[eE][+-]?\\d+)?$/; // identify integers and floats\nconst RE_DATE = /(^([\\w ]+,?[\\w ]+)?[\\w ]+,?[\\w ]+\\d+:\\d+(:\\d+)?[\\w ]?|^\\d{1,4}[/-]\\d{1,4}[/-]\\d{1,4}|^\\w+, \\w+ \\d+, \\d{4})/; // identify date strings\nconst RE_LEADING_ZERO = /^0+[1-9]{1}[0-9]*$/;\nconst RE_UNICODE_CHARACTERS = /[^\\x00-\\x80]/;\n\nexport {\n  RE_NUMBERS,\n  RE_LEADING_OR_TRAILING_WHITESPACES,\n  RE_WHITESPACES,\n  RE_INT_OR_FLOAT,\n  RE_DATE,\n  RE_LEADING_ZERO,\n  RE_UNICODE_CHARACTERS,\n};\n","// @flow\nconst compareUnicode = (stringA: string, stringB: string): number => {\n  const result = stringA.localeCompare(stringB);\n  return result ? result / Math.abs(result) : 0;\n};\n\nexport default compareUnicode;\n","// @flow\nconst stringCompare = (stringA: string, stringB: string): number => {\n  if (stringA < stringB) {\n    return -1;\n  }\n  if (stringA > stringB) {\n    return 1;\n  }\n  return 0;\n};\n\nexport default stringCompare;\n","// @flow\nimport type { Chunks } from '../types';\nimport { RE_UNICODE_CHARACTERS } from './regex';\nimport compareNumbers from './compareNumbers';\nimport compareUnicode from './compareUnicode';\nimport stringCompare from './stringCompare';\n\nconst compareChunks = (chunksA: Chunks, chunksB: Chunks): number => {\n  const lengthA = chunksA.length;\n  const lengthB = chunksB.length;\n  const size = Math.min(lengthA, lengthB);\n  for (let i = 0; i < size; i++) {\n    const chunkA = chunksA[i];\n    const chunkB = chunksB[i];\n    if (chunkA !== chunkB) {\n      if ((chunkA === '') !== (chunkB === '')) {\n        // empty strings have lowest value\n        return chunkA === '' ? -1 : 1;\n      }\n      if (typeof chunkA === 'number' && typeof chunkB === 'number') {\n        // compare numbers\n        return compareNumbers(chunkA, chunkB);\n      } else if (typeof chunkA === 'number' || typeof chunkB === 'number') {\n        // number < string\n        return typeof chunkA === 'number' ? -1 : 1;\n      } else if (\n        RE_UNICODE_CHARACTERS.test(chunkA + chunkB) &&\n        chunkA.localeCompare\n      ) {\n        // use locale comparison only if one of the chunks contains unicode characters\n        return compareUnicode(chunkA, chunkB);\n      } else {\n        // use common string comparison for performance reason\n        return stringCompare(chunkA, chunkB);\n      }\n    }\n  }\n  // if the chunks are equal so far, the one which has more chunks is greater than the other one\n  if (lengthA > size || lengthB > size) {\n    return lengthA <= size ? -1 : 1;\n  }\n  return 0;\n};\n\nexport default compareChunks;\n","// @flow\nimport type { MappedValueRecord } from '../types';\n\nconst compareOtherTypes = (\n  valueA: MappedValueRecord,\n  valueB: MappedValueRecord\n): number => {\n  if (!valueA.chunks ? valueB.chunks : !valueB.chunks) {\n    return !valueA.chunks ? 1 : -1;\n  }\n  if (valueA.isNaN ? !valueB.isNaN : valueB.isNaN) {\n    return valueA.isNaN ? -1 : 1;\n  }\n  if (valueA.isSymbol ? !valueB.isSymbol : valueB.isSymbol) {\n    return valueA.isSymbol ? -1 : 1;\n  }\n  if (valueA.isObject ? !valueB.isObject : valueB.isObject) {\n    return valueA.isObject ? -1 : 1;\n  }\n  if (valueA.isArray ? !valueB.isArray : valueB.isArray) {\n    return valueA.isArray ? -1 : 1;\n  }\n  if (valueA.isFunction ? !valueB.isFunction : valueB.isFunction) {\n    return valueA.isFunction ? -1 : 1;\n  }\n  if (valueA.isNull ? !valueB.isNull : valueB.isNull) {\n    return valueA.isNull ? -1 : 1;\n  }\n  return 0;\n};\n\nexport default compareOtherTypes;\n","// @flow\nimport type { MappedValueRecord } from '../types';\nimport compareNumbers from './compareNumbers';\nimport compareChunks from './compareChunks';\nimport compareOtherTypes from './compareOtherTypes';\n\nconst compareValues = (\n  valueA: MappedValueRecord,\n  valueB: MappedValueRecord\n): number => {\n  if (valueA.value === valueB.value) {\n    return 0;\n  }\n  if (valueA.parsedNumber !== undefined && valueB.parsedNumber !== undefined) {\n    return compareNumbers(valueA.parsedNumber, valueB.parsedNumber);\n  }\n  if (valueA.chunks && valueB.chunks) {\n    return compareChunks(valueA.chunks, valueB.chunks);\n  }\n  return compareOtherTypes(valueA, valueB);\n};\n\nexport default compareValues;\n","// @flow\nimport type { Order, MappedRecord } from '../types';\nimport compareValues from './compareValues';\n\nconst compareMultiple = (\n  recordA: MappedRecord,\n  recordB: MappedRecord,\n  orders: $ReadOnlyArray<Order>\n): number => {\n  const { values: valuesA } = recordA;\n  const { values: valuesB } = recordB;\n  const { length } = valuesA;\n  const ordersLength = orders.length;\n  for (let i = 0; i < length; i++) {\n    const order = i < ordersLength ? orders[i] : null;\n    if (order && typeof order === 'function') {\n      const result = order(valuesA[i].value, valuesB[i].value);\n      if (result) {\n        return result;\n      }\n    } else {\n      const result = compareValues(valuesA[i], valuesB[i]);\n      if (result) {\n        return result * (order === 'desc' ? -1 : 1);\n      }\n    }\n  }\n  return 0;\n};\n\nexport default compareMultiple;\n","// @flow\nimport type { Identifier, IdentifierFn } from '../types';\n\nconst createIdentifierFn = <T>(identifier: Identifier<T>): IdentifierFn<T> => {\n  if (typeof identifier === 'function') {\n    // identifier is already a lookup function\n    return identifier;\n  }\n  return (value: T): mixed => {\n    if (Array.isArray(value)) {\n      const index = Number(identifier);\n      if (Number.isInteger(index)) {\n        return value[index];\n      }\n    } else if (\n      value &&\n      typeof value === 'object' &&\n      typeof identifier !== 'function'\n    ) {\n      return value[identifier];\n    }\n    return value;\n  };\n};\n\nexport default createIdentifierFn;\n","// @flow\nimport { RE_LEADING_OR_TRAILING_WHITESPACES } from './regex';\nimport type { CaseSensitive } from '../types';\n\nconst stringify = (\n  value: string | number | boolean | Boolean | Number | String | Date | any,\n  caseSensitive: CaseSensitive\n): string => {\n  if (typeof value === 'boolean' || value instanceof Boolean) {\n    return Number(value).toString();\n  }\n  if (typeof value === 'number' || value instanceof Number) {\n    return value.toString();\n  }\n  if (value instanceof Date) {\n    return value.getTime().toString();\n  }\n  if (typeof value === 'string' || value instanceof String) {\n    return (caseSensitive ? value : value.toLowerCase()).replace(\n      RE_LEADING_OR_TRAILING_WHITESPACES,\n      ''\n    );\n  }\n  return '';\n};\n\nexport default stringify;\n","// @flow\nimport type { ParsedNumber } from '../types';\n\nconst parseNumber = (value: string): ParsedNumber | void => {\n  if (value.length !== 0) {\n    const parsedNumber = Number(value);\n    if (!Number.isNaN(parsedNumber)) {\n      return parsedNumber;\n    }\n  }\n  return undefined;\n};\n\nexport default parseNumber;\n","// @flow\nimport type { ParsedNumber } from '../types';\nimport { RE_DATE } from './regex';\n\nconst parseDate = (value: string): ParsedNumber | void => {\n  if (RE_DATE.test(value)) {\n    const parsedDate = Date.parse(value);\n    if (!Number.isNaN(parsedDate)) {\n      return parsedDate;\n    }\n  }\n  return undefined;\n};\n\nexport default parseDate;\n","// @flow\nimport parseNumber from './parseNumber';\nimport parseDate from './parseDate';\nimport type { ParsedNumber } from '../types';\n\nconst numberify = (value: string): ParsedNumber | void => {\n  const parsedNumber = parseNumber(value);\n  if (parsedNumber !== undefined) {\n    return parsedNumber;\n  }\n  return parseDate(value);\n};\n\nexport default numberify;\n","// @flow\nimport { RE_NUMBERS } from './regex';\n\nconst createChunks = (value: string): Array<string> =>\n  value\n    .replace(RE_NUMBERS, '\\0$1\\0')\n    .replace(/\\0$/, '')\n    .replace(/^\\0/, '')\n    .split('\\0');\n\nexport default createChunks;\n","// @flow\nimport type { Chunk } from '../types';\nimport {\n  RE_LEADING_OR_TRAILING_WHITESPACES,\n  RE_WHITESPACES,\n  RE_INT_OR_FLOAT,\n  RE_LEADING_ZERO,\n} from './regex';\nimport parseNumber from './parseNumber';\n\nconst normalizeChunk = (chunk: string, chunksLength: number): Chunk => {\n  if (\n    RE_INT_OR_FLOAT.test(chunk) &&\n    (!RE_LEADING_ZERO.test(chunk) || chunksLength === 1)\n  ) {\n    return parseNumber(chunk) || 0;\n  }\n  return chunk\n    .replace(RE_WHITESPACES, ' ')\n    .replace(RE_LEADING_OR_TRAILING_WHITESPACES, '');\n};\n\nexport default normalizeChunk;\n","// @flow\nimport type { Chunks } from '../types';\nimport createChunks from './createChunks';\nimport normalizeChunk from './normalizeChunk';\n\nconst createChunksList = (value: string): Chunks => {\n  const chunks = createChunks(value).map((chunk, index, array) =>\n    normalizeChunk(chunk, array.length)\n  );\n  return chunks;\n};\n\nexport default createChunksList;\n","// @flow\nconst isFunction = (value: mixed): boolean => typeof value === 'function';\n\nexport default isFunction;\n","// @flow\nconst isNaN = (value: mixed): boolean =>\n  Number.isNaN(value) ||\n  (value instanceof Number && Number.isNaN(value.valueOf()));\n\nexport default isNaN;\n","// @flow\nconst isNull = (value: mixed): boolean => value === null;\n\nexport default isNull;\n","// @flow\nconst isObject = (value: mixed): boolean =>\n  value !== null &&\n  typeof value === 'object' &&\n  !Array.isArray(value) &&\n  !(value instanceof Number) &&\n  !(value instanceof String) &&\n  !(value instanceof Boolean) &&\n  !(value instanceof Date);\n\nexport default isObject;\n","// @flow\nconst isSymbol = (value: mixed): boolean => typeof value === 'symbol';\n\nexport default isSymbol;\n","// @flow\nconst isUndefined = (value: mixed): boolean => value === undefined;\n\nexport default isUndefined;\n","// @flow\nimport type { CaseSensitive, MappedValueRecord } from '../types';\nimport stringify from './stringify';\nimport numberify from './numberify';\nimport createChunksList from './createChunksList';\nimport isFunction from './isFunction';\nimport isNaN from './isNaN';\nimport isNull from './isNull';\nimport isObject from './isObject';\nimport isSymbol from './isSymbol';\nimport isUndefined from './isUndefined';\n\nconst getMappedValueRecord = (caseSensitive: CaseSensitive = true) => (\n  value: mixed\n): MappedValueRecord => {\n  if (\n    typeof value === 'string' ||\n    value instanceof String ||\n    ((typeof value === 'number' || value instanceof Number) && !isNaN(value)) ||\n    typeof value === 'boolean' ||\n    value instanceof Boolean ||\n    value instanceof Date\n  ) {\n    const stringValue = stringify(value, caseSensitive);\n    const parsedNumber = numberify(stringValue);\n    const chunks = createChunksList(\n      parsedNumber ? `${parsedNumber}` : stringValue\n    );\n    return {\n      parsedNumber,\n      chunks,\n      value,\n    };\n  }\n  return {\n    isArray: Array.isArray(value),\n    isFunction: isFunction(value),\n    isNaN: isNaN(value),\n    isNull: isNull(value),\n    isObject: isObject(value),\n    isSymbol: isSymbol(value),\n    isUndefined: isUndefined(value),\n    value,\n  };\n};\n\nexport default getMappedValueRecord;\n","// @flow\nimport type { IdentifierFn } from '../types';\n\nconst getValueByIdentifier = <T>(\n  value: T,\n  getValue: IdentifierFn<T>\n): mixed | T => getValue(value);\n\nexport default getValueByIdentifier;\n","// @flow\nconst getElementByIndex = <T>(\n  collection: $ReadOnlyArray<T>,\n  index: number\n): T => collection[index];\n\nexport default getElementByIndex;\n","// @flow\nimport compareMultiple from './compareMultiple';\nimport createIdentifierFn from './createIdentifierFn';\nimport getMappedValueRecord from './getMappedValueRecord';\nimport getValueByIdentifier from './getValueByIdentifier';\nimport getElementByIndex from './getElementByIndex';\n\nimport type {\n  Identifier,\n  Order,\n  MappedCollection,\n  IdentifierFn,\n} from '../types';\n\nconst baseOrderBy = <T>(\n  collection: $ReadOnlyArray<T>,\n  identifiers: $ReadOnlyArray<Identifier<T>>,\n  orders: $ReadOnlyArray<Order>\n): Array<T> => {\n  const identifierFns: Array<IdentifierFn<T>> = identifiers.length\n    ? identifiers.map(createIdentifierFn)\n    : [(value: T): T => value];\n\n  // temporary array holds elements with position and sort-values\n  const mappedCollection: MappedCollection = collection.map(\n    (element, index) => {\n      const values = identifierFns\n        .map(identifier => getValueByIdentifier(element, identifier))\n        .map(getMappedValueRecord());\n      return {\n        index,\n        values,\n      };\n    }\n  );\n\n  // iterate over values and compare values until a != b or last value reached\n  mappedCollection.sort((recordA, recordB) =>\n    compareMultiple(recordA, recordB, orders)\n  );\n\n  return mappedCollection.map(element =>\n    getElementByIndex(collection, element.index)\n  );\n};\n\nexport default baseOrderBy;\n","// @flow\nimport type { Identifier } from '../types';\n\nconst getIdentifiers = <T>(\n  identifiers?: ?$ReadOnlyArray<Identifier<T>> | ?Identifier<T>\n): Array<Identifier<T>> => {\n  if (!identifiers) {\n    return [];\n  }\n  const identifierList = !Array.isArray(identifiers)\n    ? [identifiers]\n    : [...identifiers];\n  if (\n    identifierList.some(\n      identifier =>\n        typeof identifier !== 'string' &&\n        typeof identifier !== 'number' &&\n        typeof identifier !== 'function'\n    )\n  ) {\n    return [];\n  }\n  return identifierList;\n};\n\nexport default getIdentifiers;\n","// @flow\nimport type { Order } from '../types';\n\nconst getOrders = (orders?: ?$ReadOnlyArray<Order> | ?Order): Array<Order> => {\n  if (!orders) {\n    return [];\n  }\n  const orderList = !Array.isArray(orders) ? [orders] : [...orders];\n  if (\n    orderList.some(\n      order =>\n        order !== 'asc' && order !== 'desc' && typeof order !== 'function'\n    )\n  ) {\n    return [];\n  }\n  return (orderList: Array<Order>);\n};\n\nexport default getOrders;\n","// @flow\nimport baseOrderBy from '../utils/baseOrderBy';\nimport getIdentifiers from '../utils/getIdentifiers';\nimport getOrders from '../utils/getOrders';\n\nimport type { Identifier, Order } from '../types';\n\n/**\n * Creates an array of elements, natural sorted by specified identifiers and\n * the corresponding sort orders. This method implements a stable sort\n * algorithm, which means the original sort order of equal elements is\n * preserved.\n *\n * If `collection` is an array of primitives, `identifiers` may be unspecified.\n * Otherwise, you should specify `identifiers` to sort by or `collection` will\n * be returned unsorted. An identifier can expressed by:\n *\n * - an index position, if `collection` is a nested array,\n * - a property name, if `collection` is an array of objects,\n * - a function which returns a particular value from an element of a nested array or an array of objects. This function will be invoked by passing one element of `collection`.\n *\n * If `orders` is unspecified, all values are sorted in ascending order.\n * Otherwise, specify an order of `'desc'` for descending or `'asc'` for\n * ascending sort order of corresponding values. You may also specify a compare\n * function for an order, which will be invoked by two arguments:\n * `(valueA, valueB)`. It must return a number representing the sort order.\n *\n * @example\n *\n * import { orderBy } from 'natural-orderby';\n *\n * const users = [\n *   {\n *     username: 'Bamm-Bamm',\n *     ip: '192.168.5.2',\n *     datetime: 'Fri Jun 15 2018 16:48:00 GMT+0200 (CEST)'\n *   },\n *   {\n *     username: 'Wilma',\n *     ip: '192.168.10.1',\n *     datetime: '14 Jun 2018 00:00:00 PDT'\n *   },\n *   {\n *     username: 'dino',\n *     ip: '192.168.0.2',\n *     datetime: 'June 15, 2018 14:48:00'\n *   },\n *   {\n *     username: 'Barney',\n *     ip: '192.168.1.1',\n *     datetime: 'Thu, 14 Jun 2018 07:00:00 GMT'\n *   },\n *   {\n *     username: 'Pebbles',\n *     ip: '192.168.1.21',\n *     datetime: '15 June 2018 14:48 UTC'\n *   },\n *   {\n *     username: 'Hoppy',\n *     ip: '192.168.5.10',\n *     datetime: '2018-06-15T14:48:00.000Z'\n *   },\n * ];\n *\n * orderBy(\n *   users,\n *   [v => v.datetime, v => v.ip],\n *   ['desc', 'asc']\n * );\n *\n * // => [\n * //      {\n * //        username: 'dino',\n * //        ip: '192.168.0.2',\n * //        datetime: 'June 15, 2018 14:48:00',\n * //      },\n * //      {\n * //        username: 'Pebbles',\n * //        ip: '192.168.1.21',\n * //        datetime: '15 June 2018 14:48 UTC',\n * //      },\n * //      {\n * //        username: 'Bamm-Bamm',\n * //        ip: '192.168.5.2',\n * //        datetime: 'Fri Jun 15 2018 16:48:00 GMT+0200 (CEST)',\n * //      },\n * //      {\n * //        username: 'Hoppy',\n * //        ip: '192.168.5.10',\n * //        datetime: '2018-06-15T14:48:00.000Z',\n * //      },\n * //      {\n * //        username: 'Barney',\n * //        ip: '192.168.1.1',\n * //        datetime: 'Thu, 14 Jun 2018 07:00:00 GMT',\n * //      },\n * //      {\n * //        username: 'Wilma',\n * //        ip: '192.168.10.1',\n * //        datetime: '14 Jun 2018 00:00:00 PDT',\n * //      },\n * //    ]\n */\nfunction orderBy<T>(\n  collection: $ReadOnlyArray<T>,\n  identifiers?: ?$ReadOnlyArray<Identifier<T>> | ?Identifier<T>,\n  orders?: ?$ReadOnlyArray<Order> | ?Order\n): Array<T> {\n  if (!collection || !Array.isArray(collection)) {\n    return [];\n  }\n\n  const validatedIdentifiers = getIdentifiers(identifiers);\n  const validatedOrders = getOrders(orders);\n\n  return baseOrderBy(collection, validatedIdentifiers, validatedOrders);\n}\n\nexport default orderBy;\n","// @flow\nimport configureGetMappedValueRecord from './getMappedValueRecord';\nimport compareValues from './compareValues';\n\nimport type { BaseCompareOptions } from '../types';\n\nconst baseCompare = (options: BaseCompareOptions) => (\n  valueA: mixed,\n  valueB: mixed\n): number => {\n  const getMappedValueRecord = configureGetMappedValueRecord(\n    options.caseSensitive\n  );\n  const a = getMappedValueRecord(valueA);\n  const b = getMappedValueRecord(valueB);\n\n  const result = compareValues(a, b);\n  return result * (options.order === 'desc' ? -1 : 1);\n};\n\nexport default baseCompare;\n","// @flow\nimport type { CompareOptions, BaseCompareOptions } from '../types';\n\nconst defaultOptions: BaseCompareOptions = {\n  caseSensitive: true,\n  order: 'asc',\n};\n\nconst getOptions = (customOptions?: CompareOptions): BaseCompareOptions => {\n  if (!customOptions || typeof customOptions !== 'object') {\n    return defaultOptions;\n  }\n  return {\n    caseSensitive:\n      typeof customOptions.caseSensitive === 'boolean'\n        ? customOptions.caseSensitive\n        : defaultOptions.caseSensitive,\n    order:\n      customOptions.order === 'asc' || customOptions.order === 'desc'\n        ? customOptions.order\n        : defaultOptions.order,\n  };\n};\n\nexport default getOptions;\n","// @flow\nimport baseCompare from '../utils/baseCompare';\nimport getOptions from '../utils/getOptions';\n\nimport type { CompareOptions, CompareFn } from '../types';\n\n/**\n * Creates a compare function that defines the natural sort order considering\n * the given `options` which may be passed to [`Array.prototype.sort()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort).\n *\n * If `options` or its property `caseSensitive` is unspecified, values are\n * sorted case sensitive. Otherwise, specify `true` for case sensitive or\n * `false` for case insensitive sorting.\n *\n * If `options` or its property `order` is unspecified, values are sorted in\n * ascending sort order. Otherwise, specify an order of `'desc'` for descending\n * or `'asc'` for ascending sort order of values.\n *\n * @example\n *\n * import { compare } from 'natural-orderby';\n *\n * const users = [\n *   {\n *     username: 'Bamm-Bamm',\n *     lastLogin: {\n *       ip: '192.168.5.2',\n *       datetime: 'Fri Jun 15 2018 16:48:00 GMT+0200 (CEST)'\n *     },\n *   },\n *   {\n *     username: 'Wilma',\n *     lastLogin: {\n *       ip: '192.168.10.1',\n *       datetime: '14 Jun 2018 00:00:00 PDT'\n *     },\n *   },\n *   {\n *     username: 'dino',\n *     lastLogin: {\n *       ip: '192.168.0.2',\n *       datetime: 'June 15, 2018 14:48:00'\n *     },\n *   },\n *   {\n *     username: 'Barney',\n *     lastLogin: {\n *       ip: '192.168.1.1',\n *       datetime: 'Thu, 14 Jun 2018 07:00:00 GMT'\n *     },\n *   },\n *   {\n *     username: 'Pebbles',\n *     lastLogin: {\n *       ip: '192.168.1.21',\n *       datetime: '15 June 2018 14:48 UTC'\n *     },\n *   },\n *   {\n *     username: 'Hoppy',\n *     lastLogin: {\n *       ip: '192.168.5.10',\n *       datetime: '2018-06-15T14:48:00.000Z'\n *     },\n *   },\n * ];\n *\n * users.sort((a, b) => compare()(a.ip, b.ip));\n *\n * // => [\n * //      {\n * //        username: 'dino',\n * //        ip: '192.168.0.2',\n * //        datetime: 'June 15, 2018 14:48:00'\n * //      },\n * //      {\n * //        username: 'Barney',\n * //        ip: '192.168.1.1',\n * //        datetime: 'Thu, 14 Jun 2018 07:00:00 GMT'\n * //      },\n * //      {\n * //        username: 'Pebbles',\n * //        ip: '192.168.1.21',\n * //        datetime: '15 June 2018 14:48 UTC'\n * //      },\n * //      {\n * //        username: 'Bamm-Bamm',\n * //        ip: '192.168.5.2',\n * //        datetime: 'Fri Jun 15 2018 16:48:00 GMT+0200 (CEST)'\n * //      },\n * //      {\n * //        username: 'Hoppy',\n * //        ip: '192.168.5.10',\n * //        datetime: '2018-06-15T14:48:00.000Z'\n * //      },\n * //      {\n * //        username: 'Wilma',\n * //        ip: '192.168.10.1',\n * //        datetime: '14 Jun 2018 00:00:00 PDT'\n * //      }\n * //    ]\n */\nfunction compare(options?: CompareOptions): CompareFn {\n  const validatedOptions = getOptions(options);\n\n  return baseCompare(validatedOptions);\n}\n\nexport default compare;\n"],"names":["compareNumbers","numberA","numberB","RE_NUMBERS","RE_LEADING_OR_TRAILING_WHITESPACES","RE_WHITESPACES","RE_INT_OR_FLOAT","RE_DATE","RE_LEADING_ZERO","RE_UNICODE_CHARACTERS","compareUnicode","stringA","stringB","result","localeCompare","Math","abs","stringCompare","compareChunks","chunksA","chunksB","lengthA","length","lengthB","size","min","i","chunkA","chunkB","test","compareOtherTypes","valueA","valueB","chunks","isNaN","isSymbol","isObject","isArray","isFunction","isNull","compareValues","value","undefined","parsedNumber","compareMultiple","recordA","recordB","orders","valuesA","values","valuesB","ordersLength","order","createIdentifierFn","identifier","Array","index","Number","isInteger","stringify","caseSensitive","Boolean","toString","Date","getTime","String","toLowerCase","replace","parseNumber","parseDate","parsedDate","parse","numberify","createChunks","split","normalizeChunk","chunk","chunksLength","createChunksList","map","array","valueOf","isUndefined","getMappedValueRecord","stringValue","getValueByIdentifier","getValue","getElementByIndex","collection","baseOrderBy","identifiers","identifierFns","mappedCollection","element","sort","getIdentifiers","identifierList","some","getOrders","orderList","orderBy","validatedIdentifiers","validatedOrders","baseCompare","options","configureGetMappedValueRecord","a","b","defaultOptions","getOptions","customOptions","compare","validatedOptions"],"mappings":"AACA,IAAMA,eAAiB,SAACC,EAAiBC,UACnCD,EAAUC,GACJ,EAEND,EAAUC,EACL,EAEF,GCPHC,WAAa,8FACbC,mCAAqC,aACrCC,eAAiB,OACjBC,gBAAkB,kDAClBC,QAAU,+GACVC,gBAAkB,qBAClBC,sBAAwB,eCNxBC,eAAiB,SAACC,EAAiBC,OACjCC,EAASF,EAAQG,cAAcF,UAC9BC,EAASA,EAASE,KAAKC,IAAIH,GAAU,GCFxCI,cAAgB,SAACN,EAAiBC,UAClCD,EAAUC,GACJ,EAEND,EAAUC,EACL,EAEF,GCDHM,cAAgB,SAACC,EAAiBC,WAChCC,EAAUF,EAAQG,OAClBC,EAAUH,EAAQE,OAClBE,EAAOT,KAAKU,IAAIJ,EAASE,GACtBG,EAAI,EAAGA,EAAIF,EAAME,IAAK,KACvBC,EAASR,EAAQO,GACjBE,EAASR,EAAQM,MACnBC,IAAWC,QACG,KAAXD,IAA+B,KAAXC,GAEL,KAAXD,GAAiB,EAAI,EAER,iBAAXA,GAAyC,iBAAXC,EAEhC5B,eAAe2B,EAAQC,GACH,iBAAXD,GAAyC,iBAAXC,EAErB,iBAAXD,GAAuB,EAAI,EAEzClB,sBAAsBoB,KAAKF,EAASC,IACpCD,EAAOb,cAGAJ,eAAeiB,EAAQC,GAGvBX,cAAcU,EAAQC,UAK/BP,EAAUG,GAAQD,EAAUC,EACvBH,GAAWG,GAAQ,EAAI,EAEzB,GCtCHM,kBAAoB,SACxBC,EACAC,UAEKD,EAAOE,QAA0BD,EAAOC,OAAxBD,EAAOC,QAClBF,EAAOE,QAAc,EAAL,GAEtBF,EAAOG,OAASF,EAAOE,MAAQF,EAAOE,OACjCH,EAAOG,OAAS,EAAI,GAEzBH,EAAOI,UAAYH,EAAOG,SAAWH,EAAOG,UACvCJ,EAAOI,UAAY,EAAI,GAE5BJ,EAAOK,UAAYJ,EAAOI,SAAWJ,EAAOI,UACvCL,EAAOK,UAAY,EAAI,GAE5BL,EAAOM,SAAWL,EAAOK,QAAUL,EAAOK,SACrCN,EAAOM,SAAW,EAAI,GAE3BN,EAAOO,YAAcN,EAAOM,WAAaN,EAAOM,YAC3CP,EAAOO,YAAc,EAAI,GAE9BP,EAAOQ,QAAUP,EAAOO,OAASP,EAAOO,QACnCR,EAAOQ,QAAU,EAAI,EAEvB,GCtBHC,cAAgB,SACpBT,EACAC,UAEID,EAAOU,QAAUT,EAAOS,MACnB,OAEmBC,IAAxBX,EAAOY,mBAAsDD,IAAxBV,EAAOW,aACvC3C,eAAe+B,EAAOY,aAAcX,EAAOW,cAEhDZ,EAAOE,QAAUD,EAAOC,OACnBf,cAAca,EAAOE,OAAQD,EAAOC,QAEtCH,kBAAkBC,EAAQC,ICf7BY,gBAAkB,SACtBC,EACAC,EACAC,WAEgBC,EAAYH,EAApBI,OACQC,EAAYJ,EAApBG,OACA3B,EAAW0B,EAAX1B,OACF6B,EAAeJ,EAAOzB,OACnBI,EAAI,EAAGA,EAAIJ,EAAQI,IAAK,KACzB0B,EAAQ1B,EAAIyB,EAAeJ,EAAOrB,GAAK,QACzC0B,GAA0B,mBAAVA,EAAsB,KAClCvC,EAASuC,EAAMJ,EAAQtB,GAAGe,MAAOS,EAAQxB,GAAGe,UAC9C5B,SACKA,MAEJ,KACCA,EAAS2B,cAAcQ,EAAQtB,GAAIwB,EAAQxB,OAC7Cb,SACKA,GAAoB,SAAVuC,GAAoB,EAAI,WAIxC,qNCxBHC,mBAAqB,SAAIC,SACH,mBAAfA,EAEFA,EAEF,SAACb,MACFc,MAAMlB,QAAQI,GAAQ,KAClBe,EAAQC,OAAOH,MACjBG,OAAOC,UAAUF,UACZf,EAAMe,QAEV,GACLf,GACiB,qBAAVA,sBAAAA,KACe,mBAAfa,SAEAb,EAAMa,UAERb,ICjBLkB,UAAY,SAChBlB,EACAmB,SAEqB,kBAAVnB,GAAuBA,aAAiBoB,QAC1CJ,OAAOhB,GAAOqB,WAEF,iBAAVrB,GAAsBA,aAAiBgB,OACzChB,EAAMqB,WAEXrB,aAAiBsB,KACZtB,EAAMuB,UAAUF,WAEJ,iBAAVrB,GAAsBA,aAAiBwB,QACxCL,EAAgBnB,EAAQA,EAAMyB,eAAeC,QACnD/D,mCACA,IAGG,ICpBHgE,YAAc,SAAC3B,MACE,IAAjBA,EAAMnB,OAAc,KAChBqB,EAAec,OAAOhB,OACvBgB,OAAOvB,MAAMS,UACTA,ICHP0B,UAAY,SAAC5B,MACblC,QAAQsB,KAAKY,GAAQ,KACjB6B,EAAaP,KAAKQ,MAAM9B,OACzBgB,OAAOvB,MAAMoC,UACTA,ICHPE,UAAY,SAAC/B,OACXE,EAAeyB,YAAY3B,eACZC,IAAjBC,EACKA,EAEF0B,UAAU5B,ICPbgC,aAAe,SAAChC,UACpBA,EACG0B,QAAQhE,WAAY,UACpBgE,QAAQ,MAAO,IACfA,QAAQ,MAAO,IACfO,MAAM,OCELC,eAAiB,SAACC,EAAeC,UAEnCvE,gBAAgBuB,KAAK+C,IACnBpE,gBAAgBqB,KAAK+C,IAA2B,IAAjBC,EAI5BD,EACJT,QAAQ9D,eAAgB,KACxB8D,QAAQ/D,mCAAoC,IAJtCgE,YAAYQ,IAAU,GCV3BE,iBAAmB,SAACrC,UACTgC,aAAahC,GAAOsC,IAAI,SAACH,EAAOpB,EAAOwB,UACpDL,eAAeC,EAAOI,EAAM1D,WCN1BgB,WAAa,SAACG,SAA2C,mBAAVA,GCA/CP,MAAQ,SAACO,UACbgB,OAAOvB,MAAMO,IACZA,aAAiBgB,QAAUA,OAAOvB,MAAMO,EAAMwC,YCF3C1C,OAAS,SAACE,UAAoC,OAAVA,GCApCL,SAAW,SAACK,WACN,OAAVA,GACiB,qBAAVA,sBAAAA,KACNc,MAAMlB,QAAQI,IACbA,aAAiBgB,QACjBhB,aAAiBwB,QACjBxB,aAAiBoB,SACjBpB,aAAiBsB,OCPf5B,SAAW,SAACM,SAA2C,qBAAVA,sBAAAA,KCA7CyC,YAAc,SAACzC,eAAoCC,IAAVD,GCWzC0C,qBAAuB,eAACvB,oEAAwC,SACpEnB,MAGmB,iBAAVA,GACPA,aAAiBwB,SACE,iBAAVxB,GAAsBA,aAAiBgB,UAAYvB,MAAMO,IACjD,kBAAVA,GACPA,aAAiBoB,SACjBpB,aAAiBsB,KACjB,KACMqB,EAAczB,UAAUlB,EAAOmB,GAC/BjB,EAAe6B,UAAUY,gCAChBN,iBACbnC,KAAkBA,EAAiByC,2BAS5B7B,MAAMlB,QAAQI,cACXH,WAAWG,SAChBP,MAAMO,UACLF,OAAOE,YACLL,SAASK,YACTN,SAASM,eACNyC,YAAYzC,cCtCvB4C,qBAAuB,SAC3B5C,EACA6C,UACcA,EAAS7C,ICLnB8C,kBAAoB,SACxBC,EACAhC,UACMgC,EAAWhC,ICUbiC,YAAc,SAClBD,EACAE,EACA3C,OAEM4C,EAAwCD,EAAYpE,OACtDoE,EAAYX,IAAI1B,qBACf,SAACZ,UAAgBA,IAGhBmD,EAAqCJ,EAAWT,IACpD,SAACc,EAASrC,yBACOmC,EACZZ,IAAI,mBAAcM,qBAAqBQ,EAASvC,KAChDyB,IAAII,oCASMW,KAAK,SAACjD,EAASC,UAC9BF,gBAAgBC,EAASC,EAASC,KAG7B6C,EAAiBb,IAAI,mBAC1BQ,kBAAkBC,EAAYK,EAAQrC,UCvCpCuC,eAAiB,SACrBL,OAEKA,eAGCM,EAAkBzC,MAAMlB,QAAQqD,aAE9BA,IADHA,UAGHM,EAAeC,KACb,kBACwB,iBAAf3C,GACe,iBAAfA,GACe,mBAAfA,OAKN0C,GCnBHE,UAAY,SAACnD,OACZA,eAGCoD,EAAa5C,MAAMlB,QAAQU,aAAyBA,IAAdA,UAE1CoD,EAAUF,KACR,kBACY,QAAV7C,GAA6B,SAAVA,GAAqC,mBAAVA,OAK5C+C,GCuFV,SAASC,QACPZ,EACAE,EACA3C,OAEKyC,IAAejC,MAAMlB,QAAQmD,gBAI5Ba,EAAuBN,eAAeL,GACtCY,EAAkBJ,UAAUnD,UAE3B0C,YAAYD,EAAYa,EAAsBC,GC7GvD,IAAMC,YAAc,SAACC,UAAgC,SACnDzE,EACAC,OAEMmD,EAAuBsB,qBAC3BD,EAAQ5C,eAEJ8C,EAAIvB,EAAqBpD,GACzB4E,EAAIxB,EAAqBnD,UAEhBQ,cAAckE,EAAGC,IACG,SAAlBH,EAAQpD,OAAoB,EAAI,KCd7CwD,+BACW,QACR,OAGHC,WAAa,SAACC,UACbA,GAA0C,qBAAlBA,sBAAAA,mBAKc,kBAAhCA,EAAclD,cACjBkD,EAAclD,cACdgD,eAAehD,oBAEK,QAAxBkD,EAAc1D,OAA2C,SAAxB0D,EAAc1D,MAC3C0D,EAAc1D,MACdwD,eAAexD,OAVdwD,gBC4FX,SAASG,QAAQP,OACTQ,EAAmBH,WAAWL,UAE7BD,YAAYS"}