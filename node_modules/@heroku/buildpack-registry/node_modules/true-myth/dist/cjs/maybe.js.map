{"version":3,"file":"maybe.js","sourceRoot":"./","sources":["maybe.ts"],"names":[],"mappings":"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","sourcesContent":["/** [[include:doc/maybe.md]] */\n\n/** (keep typedoc from getting confused by the imports) */\nimport Result, { err, ok } from './result';\nimport { curry1, isVoid } from './utils';\n\n/**\n  Discriminant for the `Just` and `Nothing` variants.\n\n  You can use the discriminant via the `variant` property of `Maybe` instances\n  if you need to match explicitly on it.\n */\nexport enum Variant {\n  Just = 'Just',\n  Nothing = 'Nothing',\n}\n\n/** Simply defines the common shape for `Just` and `Nothing`. */\nexport interface MaybeShape<T> {\n  /** Distinguish between the `Just` and `Nothing` [variants](../enums/_maybe_.variant). */\n  readonly variant: Variant;\n\n  /** Method variant for [`Maybe.isJust`](../modules/_maybe_.html#isjust) */\n  isJust(this: Maybe<T>): this is Just<T>;\n\n  /** Method variant for [`Maybe.isNothing`](../modules/_maybe_.html#isnothing) */\n  isNothing(this: Maybe<T>): this is Nothing<T>;\n\n  /** Method variant for [`Maybe.map`](../modules/_maybe_.html#map) */\n  map<U>(this: Maybe<T>, mapFn: (t: T) => U): Maybe<U>;\n\n  /** Method variant for [`Maybe.mapOr`](../modules/_maybe_.html#mapor) */\n  mapOr<U>(this: Maybe<T>, orU: U, mapFn: (t: T) => U): U;\n\n  /** Method variant for [`Maybe.mapOrElse`](../modules/_maybe_.html#maporelse) */\n  mapOrElse<U>(this: Maybe<T>, orElseFn: () => U, mapFn: (t: T) => U): U;\n\n  /** Method variant for [`Maybe.match`](../modules/_maybe_.html#match) */\n  match<U>(this: Maybe<T>, matcher: Matcher<T, U>): U;\n\n  /** Method variant for [`Maybe.or`](../modules/_maybe_.html#or) */\n  or(this: Maybe<T>, mOr: Maybe<T>): Maybe<T>;\n\n  /** Method variant for [`Maybe.orElse`](../modules/_maybe_.html#orelse) */\n  orElse(this: Maybe<T>, orElseFn: () => Maybe<T>): Maybe<T>;\n\n  /** Method variant for [`Maybe.and`](../modules/_maybe_.html#and) */\n  and<U>(this: Maybe<T>, mAnd: Maybe<U>): Maybe<U>;\n\n  /** Method variant for [`Maybe.andThen`](../modules/_maybe_.html#andthen) */\n  andThen<U>(this: Maybe<T>, andThenFn: (t: T) => Maybe<U>): Maybe<U>;\n\n  /** Method variant for [`Maybe.chain`](../modules/_maybe_.html#chain) */\n  chain<U>(this: Maybe<T>, chainFn: (t: T) => Maybe<U>): Maybe<U>;\n\n  /** Method variant for [`Maybe.flatMap`](../modules/_maybe_.html#flatmap) */\n  flatMap<U>(this: Maybe<T>, flatMapFn: (t: T) => Maybe<U>): Maybe<U>;\n\n  /** Method variant for [`Maybe.unwrap`](../modules/_maybe_.html#unwrap) */\n  unsafelyUnwrap(): T | never;\n\n  /** Method variant for [`Maybe.unwrapOrElse`](../modules/_maybe_.html#unwraporelse) */\n  unwrapOrElse(this: Maybe<T>, elseFn: () => T): T;\n\n  /** Method variant for [`Maybe.toOkOrErr`](../modules/_maybe_.html#tookorerr) */\n  toOkOrErr<E>(this: Maybe<T>, error: E): Result<T, E>;\n\n  /** Method variant for [`Maybe.toOkOrElseErr`](../modules/_maybe_.html#tookorelseerr) */\n  toOkOrElseErr<E>(this: Maybe<T>, elseFn: () => E): Result<T, E>;\n\n  /** Method variant for [`Maybe.toString`](../modules/_maybe_.html#tostring) */\n  toString(this: Maybe<T>): string;\n\n  /** Method variant for [`Maybe.equals`](../modules/_maybe_.html#equals) */\n  equals(this: Maybe<T>, comparison: Maybe<T>): boolean;\n\n  /** Method variant for [`Maybe.ap`](../modules/_maybe_.html#ap) */\n  ap<U>(this: Maybe<(val: T) => U>, val: Maybe<T>): Maybe<U>;\n\n  /**\n    Method variant for [`Maybe.get`](../modules/_maybe_.html#prop)\n\n        If you have a `Maybe` of an object type, you can do `thatMaybe.get('a key')`\n    to look up the next layer down in the object.\n\n    ```ts\n    type DeepOptionalType = {\n      something?: {\n        with?: {\n          deeperKeys?: string;\n        }\n      }\n    };\n\n    const fullySet: DeepType = {\n      something: {\n        with: {\n          deeperKeys: 'like this'\n        }\n      }\n    };\n\n    const deepJust = Maybe.of(fullySet)\n      .get('something')\n      .get('with')\n      .get('deeperKeys');\n\n    console.log(deepJust); // Just('like this');\n\n    const partiallyUnset: DeepType = { something: { } };\n\n    const deepEmpty = Maybe.of(partiallyUnset)\n      .get('something')\n      .get('with')\n      .get('deeperKeys');\n\n    console.log(deepEmpty); // Nothing\n    ```\n   */\n  get<K extends keyof T>(this: Maybe<T>, key: K): Maybe<Required<T>[K]>;\n}\n\n/**\n  A `Just` instance is the *present* variant instance of the\n  [`Maybe`](../modules/_maybe_.html#maybe) type, representing the presence of a\n  value which may be absent. For a full discussion, see [the module\n  docs](../modules/_maybe_.html).\n\n  @typeparam T The type wrapped in this `Just` variant of `Maybe`.\n */\nexport class Just<T> implements MaybeShape<T> {\n  /**\n    Unwrap the contained value. A convenience method for functional idioms.\n\n    A common scenario where you might want to use this is in a pipeline of\n    functions:\n\n    ```ts\n    import Maybe, { Just } from 'true-myth/maybe';\n\n    function getLengths(maybeStrings: Array<Maybe<string>>): Array<number> {\n      return maybeStrings\n        .filter(Maybe.isJust)\n        .map(Just.unwrap)\n        .map(s => s.length);\n    }\n    ```\n   */\n  static unwrap<J>(theJust: Just<J>): J {\n    return theJust.value;\n  }\n\n  /** `Just` is always [`Variant.Just`](../enums/_maybe_.variant#just). */\n  readonly variant: Variant.Just = Variant.Just;\n\n  /** The wrapped value. */\n  readonly value: T;\n\n  /**\n    Create an instance of `Maybe.Just` with `new`.\n\n    @note While you *may* create the `Just` type via normal JavaScript\n    class construction, it is not recommended for the functional style for\n    which the library is intended. Instead, use [`Maybe.of`] (for the general\n    case) or [`Maybe.just`] for this specific case.\n\n    [`Maybe.of`]: ../modules/_maybe_.html#of\n    [`Maybe.just`]: ../modules/_maybe_.html#just\n\n    ```ts\n    // Avoid:\n    const aString = new Maybe.Just('characters');\n\n    // Prefer:\n    const aString = Maybe.just('characters);\n    ```\n\n    @param value\n    The value to wrap in a `Maybe.Just`.\n\n    `null` and `undefined` are allowed by the type signature so that the\n    constructor may `throw` on those rather than constructing a type like\n    `Maybe<undefined>`.\n\n    @throws      If you pass `null` or `undefined`.\n   */\n  constructor(value?: T | null) {\n    if (isVoid(value)) {\n      throw new Error('Tried to construct `Just` with `null` or `undefined`');\n    }\n\n    this.value = value;\n  }\n\n  /** Method variant for [`Maybe.isJust`](../modules/_maybe_.html#isjust) */\n  isJust(this: Maybe<T>): this is Just<T> {\n    return true;\n  }\n\n  /** Method variant for [`Maybe.isNothing`](../modules/_maybe_.html#isnothing) */\n  isNothing(this: Maybe<T>): this is Nothing<T> {\n    return false;\n  }\n\n  /** Method variant for [`Maybe.map`](../modules/_maybe_.html#map) */\n  map<U>(this: Maybe<T>, mapFn: (t: T) => U): Maybe<U> {\n    return map(mapFn, this);\n  }\n\n  /** Method variant for [`Maybe.mapOr`](../modules/_maybe_.html#mapor) */\n  mapOr<U>(this: Maybe<T>, orU: U, mapFn: (t: T) => U): U {\n    return mapOr(orU, mapFn, this);\n  }\n\n  /** Method variant for [`Maybe.mapOrElse`](../modules/_maybe_.html#maporelse) */\n  mapOrElse<U>(this: Maybe<T>, orElseFn: () => U, mapFn: (t: T) => U): U {\n    return mapOrElse(orElseFn, mapFn, this);\n  }\n\n  /** Method variant for [`Maybe.match`](../modules/_maybe_.html#match) */\n  match<U>(this: Maybe<T>, matcher: Matcher<T, U>): U {\n    return match(matcher, this);\n  }\n\n  /** Method variant for [`Maybe.or`](../modules/_maybe_.html#or) */\n  or(this: Maybe<T>, mOr: Maybe<T>): Maybe<T> {\n    return or(mOr, this);\n  }\n\n  /** Method variant for [`Maybe.orElse`](../modules/_maybe_.html#orelse) */\n  orElse(this: Maybe<T>, orElseFn: () => Maybe<T>): Maybe<T> {\n    return orElse(orElseFn, this);\n  }\n\n  /** Method variant for [`Maybe.and`](../modules/_maybe_.html#and) */\n  and<U>(this: Maybe<T>, mAnd: Maybe<U>): Maybe<U> {\n    return and(mAnd, this);\n  }\n\n  /** Method variant for [`Maybe.andThen`](../modules/_maybe_.html#andthen) */\n  andThen<U>(this: Maybe<T>, andThenFn: (t: T) => Maybe<U>): Maybe<U> {\n    return andThen(andThenFn, this);\n  }\n\n  /** Method variant for [`Maybe.chain`](../modules/_maybe_.html#chain) */\n  chain<U>(this: Maybe<T>, chainFn: (t: T) => Maybe<U>): Maybe<U> {\n    return this.andThen(chainFn);\n  }\n\n  /** Method variant for [`Maybe.flatMap`](../modules/_maybe_.html#flatmap) */\n  flatMap<U>(this: Maybe<T>, flatMapFn: (t: T) => Maybe<U>): Maybe<U> {\n    return this.andThen(flatMapFn);\n  }\n\n  /** Method variant for [`Maybe.unsafelyUnwrap`](../modules/_maybe_.html#unsafelyunwrap) */\n  unsafelyUnwrap(): T {\n    return this.value;\n  }\n\n  /** Method variant for [`Maybe.unwrapOr`](../modules/_maybe_.html#unwrapor) */\n  unwrapOr(this: Maybe<T>, defaultValue: T): T {\n    return unwrapOr(defaultValue, this);\n  }\n\n  /** Method variant for [`Maybe.unwrapOrElse`](../modules/_maybe_.html#unwraporelse) */\n  unwrapOrElse(this: Maybe<T>, elseFn: () => T): T {\n    return unwrapOrElse(elseFn, this);\n  }\n\n  /** Method variant for [`Maybe.toOkOrErr`](../modules/_maybe_.html#tookorerr) */\n  toOkOrErr<E>(this: Maybe<T>, error: E): Result<T, E> {\n    return toOkOrErr(error, this);\n  }\n\n  /** Method variant for [`Maybe.toOkOrElseErr`](../modules/_maybe_.html#tookorelseerr) */\n  toOkOrElseErr<E>(this: Maybe<T>, elseFn: () => E): Result<T, E> {\n    return toOkOrElseErr(elseFn, this);\n  }\n\n  /** Method variant for [`Maybe.toString`](../modules/_maybe_.html#tostring) */\n  toString(this: Maybe<T>): string {\n    return toString(this);\n  }\n\n  /** Method variant for [`Maybe.equals`](../modules/_maybe_.html#equals) */\n  equals(this: Maybe<T>, comparison: Maybe<T>): boolean {\n    return equals(comparison, this);\n  }\n\n  /** Method variant for [`Maybe.ap`](../modules/_maybe_.html#ap) */\n  ap<A, B>(this: Maybe<(val: A) => B>, val: Maybe<A>): Maybe<B> {\n    return ap(this, val);\n  }\n\n  /**\n    Method variant for [`Maybe.get`](../modules/_maybe_.html#prop)\n\n        If you have a `Maybe` of an object type, you can do `thatMaybe.get('a key')`\n    to look up the next layer down in the object.\n\n    ```ts\n    type DeepOptionalType = {\n      something?: {\n        with?: {\n          deeperKeys?: string;\n        }\n      }\n    };\n\n    const fullySet: DeepType = {\n      something: {\n        with: {\n          deeperKeys: 'like this'\n        }\n      }\n    };\n\n    const deepJust = Maybe.of(fullySet)\n      .get('something')\n      .get('with')\n      .get('deeperKeys');\n\n    console.log(deepJust); // Just('like this');\n\n    const partiallyUnset: DeepType = { something: { } };\n\n    const deepEmpty = Maybe.of(partiallyUnset)\n      .get('something')\n      .get('with')\n      .get('deeperKeys');\n\n    console.log(deepEmpty); // Nothing\n    ```\n   */\n  get<K extends keyof T>(this: Maybe<T>, key: K): Maybe<NonNullable<T[K]>> {\n    return this.andThen(property(key));\n  }\n}\n\n/**\n  A `Nothing` instance is the *absent* variant instance of the\n  [`Maybe`](../modules/_maybe_.html#maybe) type, representing the presence of a\n  value which may be absent. For a full discussion, see [the module\n  docs](../modules/_maybe_.html).\n\n  @typeparam T The type which would be wrapped in a `Just` variant of `Maybe`.\n */\nexport class Nothing<T> implements MaybeShape<T> {\n  /** `Nothing` is always [`Variant.Nothing`](../enums/_maybe_.variant#nothing). */\n  readonly variant: Variant.Nothing = Variant.Nothing;\n\n  /**\n    Create an instance of `Maybe.Nothing` with `new`.\n\n    @note While you *may* create the `Nothing` type via normal JavaScript\n    class construction, it is not recommended for the functional style for\n    which the library is intended. Instead, use [`Maybe.of`] (for the general\n    case) or [`Maybe.nothing`] for this specific case.\n\n    [`Maybe.of`]: ../modules/_maybe_.html#of\n    [`Maybe.nothing`]: ../modules/_maybe_.html#nothing\n\n    ```ts\n    // Avoid:\n    const aNothing = new Maybe.Err();\n\n    // Prefer:\n    const aNothing = Maybe.nothing();\n    ```\n\n    `null` and `undefined` are allowed so that you may explicitly construct the\n    `Err` type with a known `null` or `undefined` value. (This maybe helpful\n    primarily when transitioning a codebase to the use of `Maybe`.)\n\n    @throws      If you pass `null` or `undefined`.\n   */\n  constructor(_?: null) {\n    /* nothing to do */\n  }\n\n  /** Method variant for [`Maybe.isJust`](../modules/_maybe_.html#isjust) */\n  isJust(this: Maybe<T>): this is Just<T> {\n    return false;\n  }\n\n  /** Method variant for [`Maybe.isNothing`](../modules/_maybe_.html#isnothing) */\n  isNothing(this: Maybe<T>): this is Nothing<T> {\n    return true;\n  }\n\n  /** Method variant for [`Maybe.map`](../modules/_maybe_.html#map) */\n  map<U>(this: Maybe<T>, mapFn: (t: T) => U): Maybe<U> {\n    return map(mapFn, this);\n  }\n\n  /** Method variant for [`Maybe.mapOr`](../modules/_maybe_.html#mapor) */\n  mapOr<U>(this: Maybe<T>, orU: U, mapFn: (t: T) => U): U {\n    return mapOr(orU, mapFn, this);\n  }\n\n  /** Method variant for [`Maybe.mapOrElse`](../modules/_maybe_.html#maporelse) */\n  mapOrElse<U>(this: Maybe<T>, orElseFn: () => U, mapFn: (t: T) => U): U {\n    return mapOrElse(orElseFn, mapFn, this);\n  }\n\n  /** Method variant for [`Maybe.match`](../modules/_maybe_.html#match) */\n  match<U>(this: Maybe<T>, matcher: Matcher<T, U>): U {\n    return match(matcher, this);\n  }\n\n  /** Method variant for [`Maybe.or`](../modules/_maybe_.html#or) */\n  or(this: Maybe<T>, mOr: Maybe<T>): Maybe<T> {\n    return or(mOr, this);\n  }\n\n  /** Method variant for [`Maybe.orElse`](../modules/_maybe_.html#orelse) */\n  orElse(this: Maybe<T>, orElseFn: () => Maybe<T>): Maybe<T> {\n    return orElse(orElseFn, this);\n  }\n\n  /** Method variant for [`Maybe.and`](../modules/_maybe_.html#and) */\n  and<U>(this: Maybe<T>, mAnd: Maybe<U>): Maybe<U> {\n    return and(mAnd, this);\n  }\n\n  /** Method variant for [`Maybe.andThen`](../modules/_maybe_.html#andthen) */\n  andThen<U>(this: Maybe<T>, andThenFn: (t: T) => Maybe<U>): Maybe<U> {\n    return andThen(andThenFn, this);\n  }\n\n  /** Method variant for [`Maybe.chain`](../modules/_maybe_.html#chain) */\n  chain<U>(this: Maybe<T>, chainFn: (t: T) => Maybe<U>): Maybe<U> {\n    return this.andThen(chainFn);\n  }\n\n  /** Method variant for [`Maybe.flatMap`](../modules/_maybe_.html#flatmap) */\n  flatMap<U>(this: Maybe<T>, flatMapFn: (t: T) => Maybe<U>): Maybe<U> {\n    return this.andThen(flatMapFn);\n  }\n\n  /** Method variant for [`Maybe.unsafelyUnwrap`](../modules/_maybe_.html#unsafelyunwrap) */\n  unsafelyUnwrap(): never {\n    throw new Error('Tried to `unsafelyUnwrap(Nothing)`');\n  }\n\n  /** Method variant for [`Maybe.unwrapOr`](../modules/_maybe_.html#unwrapor) */\n  unwrapOr(this: Maybe<T>, defaultValue: T): T {\n    return unwrapOr(defaultValue, this);\n  }\n\n  /** Method variant for [`Maybe.unwrapOrElse`](../modules/_maybe_.html#unwraporelse) */\n  unwrapOrElse(this: Maybe<T>, elseFn: () => T): T {\n    return unwrapOrElse(elseFn, this);\n  }\n\n  /** Method variant for [`Maybe.toOkOrErr`](../modules/_maybe_.html#tookorerr) */\n  toOkOrErr<E>(this: Maybe<T>, error: E): Result<T, E> {\n    return toOkOrErr(error, this);\n  }\n\n  /** Method variant for [`Maybe.toOkOrElseErr`](../modules/_maybe_.html#tookorelseerr) */\n  toOkOrElseErr<E>(this: Maybe<T>, elseFn: () => E): Result<T, E> {\n    return toOkOrElseErr(elseFn, this);\n  }\n\n  /** Method variant for [`Maybe.toString`](../modules/_maybe_.html#tostring) */\n  toString(this: Maybe<T>): string {\n    return toString(this);\n  }\n\n  /** Method variant for [`Maybe.equals`](../modules/_maybe_.html#equals) */\n  equals(this: Maybe<T>, comparison: Maybe<T>): boolean {\n    return equals(comparison, this);\n  }\n\n  /** Method variant for [`Maybe.ap`](../modules/_maybe_.html#ap) */\n  ap<A, B>(this: Maybe<(val: A) => B>, val: Maybe<A>): Maybe<B> {\n    return ap(this, val);\n  }\n\n  /**\n    Method variant for [`Maybe.get`](../modules/_maybe_.html#prop)\n\n        If you have a `Maybe` of an object type, you can do `thatMaybe.get('a key')`\n    to look up the next layer down in the object.\n\n    ```ts\n    type DeepOptionalType = {\n      something?: {\n        with?: {\n          deeperKeys?: string;\n        }\n      }\n    };\n\n    const fullySet: DeepType = {\n      something: {\n        with: {\n          deeperKeys: 'like this'\n        }\n      }\n    };\n\n    const deepJust = Maybe.of(fullySet)\n      .get('something')\n      .get('with')\n      .get('deeperKeys');\n\n    console.log(deepJust); // Just('like this');\n\n    const partiallyUnset: DeepType = { something: { } };\n\n    const deepEmpty = Maybe.of(partiallyUnset)\n      .get('something')\n      .get('with')\n      .get('deeperKeys');\n\n    console.log(deepEmpty); // Nothing\n    ```\n   */\n  get<K extends keyof T>(this: Maybe<T>, key: K): Maybe<NonNullable<T[K]>> {\n    return this.andThen(property(key));\n  }\n}\n\n/**\n  Is this result a `Just` instance?\n\n  @typeparam T The type of the wrapped value.\n  @param maybe The `Maybe` instance to check.\n  @returns     `true` if `maybe` is `Just`, `false` otherwise. In TypeScript,\n               also narrows the type from `Maybe<T>` to `Just<T>`.\n */\nexport function isJust<T>(maybe: Maybe<T>): maybe is Just<T> {\n  return maybe.variant === Variant.Just;\n}\n\n/**\n  Is this result a `Nothing` instance?\n\n  @typeparam T The type of the wrapped value.\n  @param maybe The `Maybe` instance to check.\n  @returns     `true` if `maybe` is `nothing`, `false` otherwise. In TypeScript,\n               also narrows the type from `Maybe<T>` to `Nothing<T>`.\n */\nexport function isNothing<T>(maybe: Maybe<T>): maybe is Nothing<T> {\n  return maybe.variant === Variant.Nothing;\n}\n\n/**\n  Create an instance of `Maybe.Just`.\n\n  `null` and `undefined` are allowed by the type signature so that the\n  function may `throw` on those rather than constructing a type like\n  `Maybe<undefined>`.\n\n  @typeparam T The type of the item contained in the `Maybe`.\n  @param value The value to wrap in a `Maybe.Just`.\n  @returns     An instance of `Maybe.Just<T>`.\n  @throws      If you pass `null` or `undefined`.\n */\nexport function just<T>(value?: T | null): Maybe<T> {\n  return new Just<T>(value);\n}\n\n/**\n  Create an instance of `Maybe.Nothing`.\n\n  If you want to create an instance with a specific type, e.g. for use in a\n  function which expects a `Maybe<T>` where the `<T>` is known but you have no\n  value to give it, you can use a type parameter:\n\n  ```ts\n  const notString = Maybe.nothing<string>();\n  ```\n\n  @typeparam T The type of the item contained in the `Maybe`.\n  @returns     An instance of `Maybe.Nothing<T>`.\n */\nexport function nothing<T>(_?: null): Maybe<T> {\n  return new Nothing<T>(_);\n}\n\n/**\n  Create a `Maybe` from any value.\n\n  To specify that the result should be interpreted as a specific type, you may\n  invoke `Maybe.of` with an explicit type parameter:\n\n  ```ts\n  const foo = Maybe.of<string>(null);\n  ```\n\n  This is usually only important in two cases:\n\n  1.  If you are intentionally constructing a `Nothing` from a known `null` or\n      undefined value *which is untyped*.\n  2.  If you are specifying that the type is more general than the value passed\n      (since TypeScript can define types as literals).\n\n  @typeparam T The type of the item contained in the `Maybe`.\n  @param value The value to wrap in a `Maybe`. If it is `undefined` or `null`,\n               the result will be `Nothing`; otherwise it will be the type of\n               the value passed.\n */\nexport function of<T>(value?: T | null): Maybe<T> {\n  return isVoid(value) ? nothing<T>() : just(value);\n}\n\n/** Alias for [`of`](#of), primarily for compatibility with Folktale. */\nexport const fromNullable = of;\n\n/**\n  Map over a `Maybe` instance: apply the function to the wrapped value if the\n  instance is `Just`, and return `Nothing` if the instance is `Nothing`.\n\n  `Maybe.map` works a lot like `Array.prototype.map`: `Maybe` and `Array` are\n  both *containers* for other things. If you have no items in an array of\n  numbers named `foo` and call `foo.map(x => x + 1)`, you'll still just have an\n  array with nothing in it. But if you have any items in the array (`[2, 3]`),\n  and you call `foo.map(x => x + 1)` on it, you'll get a new array with each of\n  those items inside the array \"container\" transformed (`[3, 4]`).\n\n  That's exactly what's happening with `Maybe.map`. If the container is *empty*\n  – the `Nothing` variant – you just get back an empty container. If the\n  container has something in it – the `Just` variant – you get back a container\n  with the item inside transformed.\n\n  (So... why not just use an array? The biggest reason is that an array can be\n  any length. With a `Maybe`, we're capturing the idea of \"something or\n  nothing\" rather than \"0 to n\" items. And this lets us implement a whole set\n  of *other* interfaces, like those in this module.)\n\n  #### Examples\n\n  ```ts\n  const length = (s: string) => s.length;\n\n  const justAString = Maybe.just('string');\n  const justTheStringLength = map(length, justAString);\n  console.log(justTheStringLength.toString()); // Just(6)\n\n  const notAString = Maybe.nothing<string>();\n  const notAStringLength = map(length, notAString);\n  console.log(notAStringLength.toString()); // \"Nothing\"\n  ```\n\n  @typeparam T The type of the wrapped value.\n  @typeparam U The type of the wrapped value of the returned `Maybe`.\n  @param mapFn The function to apply the value to if `Maybe` is `Just`.\n  @param maybe The `Maybe` instance to map over.\n  @returns     A new `Maybe` with the result of applying `mapFn` to the value\n               in a `Just`, or `Nothing` if `maybe` is `Nothing`.\n */\nexport function map<T, U>(mapFn: (t: T) => U): (maybe: Maybe<T>) => Maybe<U>;\nexport function map<T, U>(mapFn: (t: T) => U, maybe: Maybe<T>): Maybe<U>;\nexport function map<T, U>(\n  mapFn: (t: T) => U,\n  maybe?: Maybe<T>\n): Maybe<U> | ((maybe: Maybe<T>) => Maybe<U>) {\n  const op = (m: Maybe<T>) => (m.isJust() ? just(mapFn(m.value)) : nothing<U>());\n  return curry1(op, maybe);\n}\n\n/**\n  Map over a `Maybe` instance and get out the value if `maybe` is a `Just`, or\n  return a default value if `maybe` is a `Nothing`.\n\n  #### Examples\n\n  ```ts\n  const length = (s: string) => s.length;\n\n  const justAString = Maybe.just('string');\n  const theStringLength = mapOr(0, length, justAString);\n  console.log(theStringLength); // 6\n\n  const notAString = Maybe.nothing<string>();\n  const notAStringLength = mapOr(0, length, notAString)\n  console.log(notAStringLength); // 0\n  ```\n\n  @typeparam T The type of the wrapped value.\n  @typeparam U The type of the wrapped value of the returned `Maybe`.\n  @param orU   The default value to use if `maybe` is `Nothing`\n  @param mapFn The function to apply the value to if `Maybe` is `Just`\n  @param maybe The `Maybe` instance to map over.\n */\nexport function mapOr<T, U>(orU: U, mapFn: (t: T) => U, maybe: Maybe<T>): U;\nexport function mapOr<T, U>(orU: U, mapFn: (t: T) => U): (maybe: Maybe<T>) => U;\nexport function mapOr<T, U>(orU: U): (mapFn: (t: T) => U) => (maybe: Maybe<T>) => U;\nexport function mapOr<T, U>(\n  orU: U,\n  mapFn?: (t: T) => U,\n  maybe?: Maybe<T>\n): U | ((maybe: Maybe<T>) => U) | ((mapFn: (t: T) => U) => (maybe: Maybe<T>) => U) {\n  function fullOp(fn: (t: T) => U, m: Maybe<T>) {\n    return m.isJust() ? fn(m.value) : orU;\n  }\n\n  function partialOp(fn: (t: T) => U): (maybe: Maybe<T>) => U;\n  function partialOp(fn: (t: T) => U, curriedMaybe: Maybe<T>): U;\n  function partialOp(fn: (t: T) => U, curriedMaybe?: Maybe<T>): U | ((maybe: Maybe<T>) => U) {\n    return curriedMaybe !== undefined\n      ? fullOp(fn, curriedMaybe)\n      : (extraCurriedMaybe: Maybe<T>) => fullOp(fn, extraCurriedMaybe);\n  }\n\n  return mapFn === undefined\n    ? partialOp\n    : maybe === undefined\n      ? partialOp(mapFn)\n      : partialOp(mapFn, maybe);\n}\n\n/**\n  Map over a `Maybe` instance and get out the value if `maybe` is a `Just`,\n  or use a function to construct a default value if `maybe` is `Nothing`.\n\n  #### Examples\n\n  ```ts\n  const length = (s: string) => s.length;\n  const getDefault = () => 0;\n\n  const justAString = Maybe.just('string');\n  const theStringLength = mapOrElse(getDefault, length, justAString);\n  console.log(theStringLength); // 6\n\n  const notAString = Maybe.nothing<string>();\n  const notAStringLength = mapOrElse(getDefault, length, notAString)\n  console.log(notAStringLength); // 0\n  ```\n\n  @typeparam T    The type of the wrapped value.\n  @typeparam U    The type of the wrapped value of the returned `Maybe`.\n  @param orElseFn The function to apply if `maybe` is `Nothing`.\n  @param mapFn    The function to apply to the wrapped value if `maybe` is `Just`\n  @param maybe    The `Maybe` instance to map over.\n */\nexport function mapOrElse<T, U>(orElseFn: () => U, mapFn: (t: T) => U, maybe: Maybe<T>): U;\nexport function mapOrElse<T, U>(orElseFn: () => U, mapFn: (t: T) => U): (maybe: Maybe<T>) => U;\nexport function mapOrElse<T, U>(orElseFn: () => U): (mapFn: (t: T) => U) => (maybe: Maybe<T>) => U;\nexport function mapOrElse<T, U>(\n  orElseFn: () => U,\n  mapFn?: (t: T) => U,\n  maybe?: Maybe<T>\n): U | ((maybe: Maybe<T>) => U) | ((mapFn: (t: T) => U) => (maybe: Maybe<T>) => U) {\n  function fullOp(fn: (t: T) => U, m: Maybe<T>) {\n    return m.isJust() ? fn(m.value) : orElseFn();\n  }\n\n  function partialOp(fn: (t: T) => U): (maybe: Maybe<T>) => U;\n  function partialOp(fn: (t: T) => U, curriedMaybe: Maybe<T>): U;\n  function partialOp(fn: (t: T) => U, curriedMaybe?: Maybe<T>): U | ((maybe: Maybe<T>) => U) {\n    return curriedMaybe !== undefined\n      ? fullOp(fn, curriedMaybe)\n      : (extraCurriedMaybe: Maybe<T>) => fullOp(fn, extraCurriedMaybe);\n  }\n\n  if (mapFn === undefined) {\n    return partialOp;\n  } else if (maybe === undefined) {\n    return partialOp(mapFn);\n  } else {\n    return partialOp(mapFn, maybe);\n  }\n}\n\n/**\n  You can think of this like a short-circuiting logical \"and\" operation on a\n  `Maybe` type. If `maybe` is `Just`, then the result is the `andMaybe`. If\n  `maybe` is `Nothing`, the result is `Nothing`.\n\n  This is useful when you have another `Maybe` value you want to provide if and\n  *only if* you have a `Just` – that is, when you need to make sure that if you\n  `Nothing`, whatever else you're handing a `Maybe` to *also* gets a `Nothing`.\n\n  Notice that, unlike in [`map`](#map) or its variants, the original `maybe` is\n  not involved in constructing the new `Maybe`.\n\n  #### Examples\n\n  ```ts\n  import Maybe from 'true-myth/maybe';\n\n  const justA = Maybe.just('A');\n  const justB = Maybe.just('B');\n  const nothing: Maybe<number> = nothing();\n\n  console.log(Maybe.and(justB, justA).toString());  // Just(B)\n  console.log(Maybe.and(justB, nothing).toString());  // Nothing\n  console.log(Maybe.and(nothing, justA).toString());  // Nothing\n  console.log(Maybe.and(nothing, nothing).toString());  // Nothing\n  ```\n\n  @typeparam T    The type of the initial wrapped value.\n  @typeparam U    The type of the wrapped value of the returned `Maybe`.\n  @param andMaybe The `Maybe` instance to return if `maybe` is `Just`\n  @param maybe    The `Maybe` instance to check.\n  @return         `Nothing` if the original `maybe` is `Nothing`, or `andMaybe`\n                  if the original `maybe` is `Just`.\n */\nexport function and<T, U>(andMaybe: Maybe<U>, maybe: Maybe<T>): Maybe<U>;\nexport function and<T, U>(andMaybe: Maybe<U>): (maybe: Maybe<T>) => Maybe<U>;\nexport function and<T, U>(\n  andMaybe: Maybe<U>,\n  maybe?: Maybe<T>\n): Maybe<U> | ((maybe: Maybe<T>) => Maybe<U>) {\n  const op = (m: Maybe<T>) => (m.isJust() ? andMaybe : nothing<U>());\n  return curry1(op, maybe);\n}\n\n/**\n  Apply a function to the wrapped value if `Just` and return a new `Just`\n  containing the resulting value; or return `Nothing` if `Nothing`.\n\n  This differs from `map` in that `thenFn` returns another `Maybe`. You can use\n  `andThen` to combine two functions which *both* create a `Maybe` from an\n  unwrapped type.\n\n  You may find the `.then` method on an ES6 `Promise` helpful for b:\n  if you have a `Promise`, you can pass its `then` method a callback which\n  returns another `Promise`, and the result will not be a *nested* promise, but\n  a single `Promise`. The difference is that `Promise#then` unwraps *all*\n  layers to only ever return a single `Promise` value, whereas `Maybe.andThen`\n  will not unwrap nested `Maybe`s.\n\n  This is also commonly known as (and therefore aliased as) [`flatMap`] or\n  [`chain`]. It is sometimes also known as `bind`, but *not* aliased as such\n  because [`bind` already means something in JavaScript][bind].\n\n  [`flatMap`]: #flatmap\n  [`chain`]: #chain\n  [bind]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\n\n  #### Example\n\n  (This is a somewhat contrived example, but it serves to show the way the\n  function behaves.)\n\n  ```ts\n  import Maybe from 'true-myth/maybe';\n\n  // string -> Maybe<number>\n  const toMaybeLength = (s: string): Maybe<number> => Maybe.of(s.length);\n\n  // Maybe<string>\n  const aMaybeString = Maybe.of('Hello, there!');\n\n  // Maybe<number>\n  const resultingLength = Maybe.andThen(toMaybeLength, aMaybeString);\n  console.log(Maybe.toString(resultingLength)); // 13\n  ```\n\n  Note that the result is not `(Just(13))`, but `13`!\n\n  @typeparam T  The type of the wrapped value.\n  @typeparam T  The type of the wrapped value in the resulting `Maybe`.\n  @param thenFn The function to apply to the wrapped `T` if `maybe` is `Just`.\n  @param maybe  The `Maybe` to evaluate and possibly apply a function to the\n                contents of.\n  @returns      The result of the `thenFn` (a new `Maybe`) if `maybe` is a\n                `Just`, otherwise `Nothing` if `maybe` is a `Nothing`.\n */\nexport function andThen<T, U>(thenFn: (t: T) => Maybe<U>, maybe: Maybe<T>): Maybe<U>;\nexport function andThen<T, U>(thenFn: (t: T) => Maybe<U>): (maybe: Maybe<T>) => Maybe<U>;\nexport function andThen<T, U>(\n  thenFn: (t: T) => Maybe<U>,\n  maybe?: Maybe<T>\n): Maybe<U> | ((maybe: Maybe<T>) => Maybe<U>) {\n  const op = (m: Maybe<T>) => (m.isJust() ? thenFn(m.value) : nothing<U>());\n  return maybe !== undefined ? op(maybe) : op;\n}\n\n/** Alias for [`andThen`](#andthen). */\nexport const chain = andThen;\n\n/** Alias for [`andThen`](#andthen). */\nexport const flatMap = andThen;\n\n/**\n  Provide a fallback for a given `Maybe`. Behaves like a logical `or`: if the\n  `maybe` value is a `Just`, returns that `maybe`; otherwise, returns the\n  `defaultMaybe` value.\n\n  This is useful when you want to make sure that something which takes a\n  `Maybe` always ends up getting a `Just` variant, by supplying a default value\n  for the case that you currently have a nothing.\n\n  ```ts\n  import Maybe from 'true-utils/maybe';\n\n  const justA = Maybe.just(\"a\");\n  const justB = Maybe.just(\"b\");\n  const aNothing: Maybe<string> = nothing();\n\n  console.log(Maybe.or(justB, justA).toString());  // Just(A)\n  console.log(Maybe.or(aNothing, justA).toString());  // Just(A)\n  console.log(Maybe.or(justB, aNothing).toString());  // Just(B)\n  console.log(Maybe.or(aNothing, aNothing).toString());  // Nothing\n  ```\n\n  @typeparam T        The type of the wrapped value.\n  @param defaultMaybe The `Maybe` to use if `maybe` is a `Nothing`.\n  @param maybe        The `Maybe` instance to evaluate.\n  @returns            `maybe` if it is a `Just`, otherwise `defaultMaybe`.\n */\nexport function or<T>(defaultMaybe: Maybe<T>, maybe: Maybe<T>): Maybe<T>;\nexport function or<T>(defaultMaybe: Maybe<T>): (maybe: Maybe<T>) => Maybe<T>;\nexport function or<T>(\n  defaultMaybe: Maybe<T>,\n  maybe?: Maybe<T>\n): Maybe<T> | ((maybe: Maybe<T>) => Maybe<T>) {\n  const op = (m: Maybe<T>) => (m.isJust() ? m : defaultMaybe);\n  return maybe !== undefined ? op(maybe) : op;\n}\n\n/**\n  Like `or`, but using a function to construct the alternative `Maybe`.\n\n  Sometimes you need to perform an operation using other data in the\n  environment to construct the fallback value. In these situations, you can\n  pass a function (which may be a closure) as the `elseFn` to generate the\n  fallback `Maybe<T>`.\n\n  Useful for transforming empty scenarios based on values in context.\n\n  @typeparam T  The type of the wrapped value.\n  @param elseFn The function to apply if `maybe` is `Nothing`\n  @param maybe  The `maybe` to use if it is `Just`.\n  @returns      The `maybe` if it is `Just`, or the `Maybe` returned by\n                `elseFn` if the `maybe` is `Nothing`.\n */\nexport function orElse<T>(elseFn: () => Maybe<T>, maybe: Maybe<T>): Maybe<T>;\nexport function orElse<T>(elseFn: () => Maybe<T>): (maybe: Maybe<T>) => Maybe<T>;\nexport function orElse<T>(\n  elseFn: () => Maybe<T>,\n  maybe?: Maybe<T>\n): Maybe<T> | ((maybe: Maybe<T>) => Maybe<T>) {\n  const op = (m: Maybe<T>) => (m.isJust() ? m : elseFn());\n  return curry1(op, maybe);\n}\n\n/**\n  Get the value out of the `Maybe`.\n\n  Returns the content of a `Just`, but **throws if the `Maybe` is `Nothing`**.\n  Prefer to use [`unwrapOr`](#unwrapor) or [`unwrapOrElse`](#unwraporelse).\n\n  @typeparam T The type of the wrapped value.\n  @param maybe The value to unwrap\n  @returns     The unwrapped value if the `Maybe` instance is `Just`.\n  @throws      If the `maybe` is `Nothing`.\n */\nexport function unsafelyUnwrap<T>(maybe: Maybe<T>): T {\n  return maybe.unsafelyUnwrap();\n}\n\n/** Alias for [`unsafelyUnwrap`](#unsafelyunwrap) */\nexport const unsafelyGet = unsafelyUnwrap;\n\n/** Alias for [`unsafelyUnwrap`](#unsafelyunwrap) */\nexport const unsafeGet = unsafelyUnwrap;\n\n/**\n  Safely get the value out of a `Maybe`.\n\n  Returns the content of a `Just` or `defaultValue` if `Nothing`. This is the\n  recommended way to get a value out of a `Maybe` most of the time.\n\n  ```ts\n  import Maybe from 'true-myth/maybe';\n\n  const notAString = Maybe.nothing<string>();\n  const isAString = Maybe.just('look ma! some characters!');\n\n  console.log(Maybe.unwrapOr('<empty>', notAString));  // \"<empty>\"\n  console.log(Maybe.unwrapOr('<empty>', isAString));  // \"look ma! some characters!\"\n  ```\n\n  @typeparam T        The type of the wrapped value.\n  @param defaultValue The value to return if `maybe` is a `Nothing`.\n  @param maybe        The `Maybe` instance to unwrap if it is a `Just`.\n  @returns            The content of `maybe` if it is a `Just`, otherwise\n                      `defaultValue`.\n */\nexport function unwrapOr<T>(defaultValue: T, maybe: Maybe<T>): T;\nexport function unwrapOr<T>(defaultValue: T): (maybe: Maybe<T>) => T;\nexport function unwrapOr<T>(defaultValue: T, maybe?: Maybe<T>) {\n  const op = (m: Maybe<T>) => (m.isJust() ? m.value : defaultValue);\n  return curry1(op, maybe);\n}\n\n/** Alias for [`unwrapOr`](#unwrapor) */\nexport const getOr = unwrapOr;\n\n/**\n  Safely get the value out of a [`Maybe`](#maybe) by returning the wrapped\n  value if it is `Just`, or by applying `orElseFn` if it is `Nothing`.\n\n  This is useful when you need to *generate* a value (e.g. by using current\n  values in the environment – whether preloaded or by local closure) instead of\n  having a single default value available (as in [`unwrapOr`](#unwrapor)).\n\n  ```ts\n  import Maybe from 'true-myth/maybe';\n\n  // You can imagine that someOtherValue might be dynamic.\n  const someOtherValue = 99;\n  const handleNothing = () => someOtherValue;\n\n  const aJust = Maybe.just(42);\n  console.log(Maybe.unwrapOrElse(handleNothing, aJust));  // 42\n\n  const aNothing = nothing<number>();\n  console.log(Maybe.unwrapOrElse(handleNothing, aNothing)); // 99\n  ```\n\n  @typeparam T  The wrapped value.\n  @param orElseFn A function used to generate a valid value if `maybe` is a\n                  `Nothing`.\n  @param maybe    The `Maybe` instance to unwrap if it is a `Just`\n  @returns        Either the content of `maybe` or the value returned from\n                  `orElseFn`.\n */\nexport function unwrapOrElse<T>(orElseFn: () => T, maybe: Maybe<T>): T;\nexport function unwrapOrElse<T>(orElseFn: () => T): (maybe: Maybe<T>) => T;\nexport function unwrapOrElse<T>(orElseFn: () => T, maybe?: Maybe<T>): T | ((maybe: Maybe<T>) => T) {\n  const op = (m: Maybe<T>) => (m.isJust() ? m.value : orElseFn());\n  return curry1(op, maybe);\n}\n\n/** Alias for [`unwrapOrElse`](#unwraporelse) */\nexport const getOrElse = unwrapOrElse;\n\n/**\n  Transform the [`Maybe`](#maybe) into a\n  [`Result`](../modules/_result_.html#result), using the wrapped value as the\n  `Ok` value if `Just`; otherwise using the supplied `error` value for `Err`.\n\n  @typeparam T  The wrapped value.\n  @typeparam E  The error type to in the `Result`.\n  @param error The error value to use if the `Maybe` is `Nothing`.\n  @param maybe The `Maybe` instance to convert.\n  @returns     A `Result` containing the value wrapped in `maybe` in an `Ok`,\n               or `error` in an `Err`.\n */\nexport function toOkOrErr<T, E>(error: E, maybe: Maybe<T>): Result<T, E>;\nexport function toOkOrErr<T, E>(error: E): (maybe: Maybe<T>) => Result<T, E>;\nexport function toOkOrErr<T, E>(\n  error: E,\n  maybe?: Maybe<T>\n): Result<T, E> | ((maybe: Maybe<T>) => Result<T, E>) {\n  const op = (m: Maybe<T>) => (m.isJust() ? ok<T, E>(m.value) : err<T, E>(error));\n  return maybe !== undefined ? op(maybe) : op;\n}\n\n/**\n  Transform the [`Maybe`](#maybe) into a\n  [`Result`](../modules/_result_.html#result), using the wrapped value as the\n  `Ok` value if `Just`; otherwise using `elseFn` to generate `Err`.\n\n  @typeparam T  The wrapped value.\n  @typeparam E  The error type to in the `Result`.\n  @param elseFn The function which generates an error of type `E`.\n  @param maybe  The `Maybe` instance to convert.\n  @returns     A `Result` containing the value wrapped in `maybe` in an `Ok`,\n               or the value generated by `elseFn` in an `Err`.\n */\nexport function toOkOrElseErr<T, E>(elseFn: () => E, maybe: Maybe<T>): Result<T, E>;\nexport function toOkOrElseErr<T, E>(elseFn: () => E): (maybe: Maybe<T>) => Result<T, E>;\nexport function toOkOrElseErr<T, E>(\n  elseFn: () => E,\n  maybe?: Maybe<T>\n): Result<T, E> | ((maybe: Maybe<T>) => Result<T, E>) {\n  const op = (m: Maybe<T>) => (m.isJust() ? ok<T, E>(m.value) : err<T, E>(elseFn()));\n  return curry1(op, maybe);\n}\n\n/**\n  Construct a `Maybe<T>` from a `Result<T, E>`.\n\n  If the `Result` is an `Ok`, wrap its value in `Just`. If the `Result` is an\n  `Err`, throw away the wrapped `E` and transform to a `Nothing`.\n\n  @typeparam T  The type of the value wrapped in a `Result.Ok` and in the `Just`\n                of the resulting `Maybe`.\n  @typeparam E  The type of the value wrapped in a `Result.Err`; thrown away in\n                the resulting `Maybe`.\n  @param result The `Result` to construct a `Maybe` from.\n  @returns      `Just` if `result` was `Ok` or `Nothing` if it was `Err`.\n */\nexport function fromResult<T>(result: Result<T, any>): Maybe<T> {\n  return result.isOk() ? just(result.value) : nothing<T>();\n}\n\n/**\n  Create a `String` representation of a `Maybe` instance.\n\n  A `Just` instance will be printed as `Just(<representation of the value>)`,\n  where the representation of the value is simply the value's own `toString`\n  representation. For example:\n\n  | call                                   | output                  |\n  |----------------------------------------|-------------------------|\n  | `toString(Maybe.of(42))`               | `Just(42)`              |\n  | `toString(Maybe.of([1, 2, 3]))`        | `Just(1,2,3)`           |\n  | `toString(Maybe.of({ an: 'object' }))` | `Just([object Object])` |\n  | `toString(Maybe.nothing())`            | `Nothing`               |\n\n  @typeparam T The type of the wrapped value; its own `.toString` will be used\n               to print the interior contents of the `Just` variant.\n  @param maybe The value to convert to a string.\n  @returns     The string representation of the `Maybe`.\n */\nexport function toString<T>(maybe: Maybe<T>): string {\n  const body = maybe.isJust() ? `(${maybe.value.toString()})` : '';\n  return `${maybe.variant}${body}`;\n}\n\n/** A lightweight object defining how to handle each variant of a Maybe. */\nexport type Matcher<T, A> = {\n  Just: (value: T) => A;\n  Nothing: () => A;\n};\n\n/**\n  Performs the same basic functionality as `getOrElse`, but instead of simply\n  unwrapping the value if it is `Just` and applying a value to generate the same\n  default type if it is `Nothing`, lets you supply functions which may transform\n  the wrapped type if it is `Just` or get a default value for `Nothing`.\n\n  This is kind of like a poor man's version of pattern matching, which\n  JavaScript currently lacks.\n\n  Instead of code like this:\n\n  ```ts\n  import Maybe from 'true-myth/maybe';\n\n  const logValue = (mightBeANumber: Maybe<number>) => {\n    const valueToLog = Maybe.mightBeANumber.isJust()\n      ? Maybe.unsafelyUnwrap(mightBeANumber).toString()\n      : 'Nothing to log.';\n\n    console.log(valueToLog);\n  };\n  ```\n\n  ...we can write code like this:\n\n  ```ts\n  import Maybe from 'true-myth/maybe';\n\n  const logValue = (mightBeANumber: Maybe<number>) => {\n    const value = Maybe.match(\n      {\n        Just: n => n.toString(),\n        Nothing: () => 'Nothing to log.',\n      },\n      mightBeANumber\n    );\n\n    console.log(value);\n  };\n  ```\n\n  This is slightly longer to write, but clearer: the more complex the resulting\n  expression, the hairer it is to understand the ternary. Thus, this is\n  especially convenient for times when there is a complex result, e.g. when\n  rendering part of a React component inline in JSX/TSX.\n\n  @param matcher A lightweight object defining what to do in the case of each\n                 variant.\n  @param maybe   The `maybe` instance to check.\n */\nexport function match<T, A>(matcher: Matcher<T, A>, maybe: Maybe<T>): A;\nexport function match<T, A>(matcher: Matcher<T, A>): (m: Maybe<T>) => A;\nexport function match<T, A>(matcher: Matcher<T, A>, maybe?: Maybe<T>): A | ((m: Maybe<T>) => A) {\n  return maybe !== undefined\n    ? mapOrElse(matcher.Nothing, matcher.Just, maybe)\n    : (curriedMaybe: Maybe<T>) => mapOrElse(matcher.Nothing, matcher.Just, curriedMaybe);\n}\n\n/** Alias for [`match`](#match) */\nexport const cata = match;\n\n/**\n  Allows quick triple-equal equality check between the values inside two `maybe`s\n  without having to unwrap them first.\n\n  ```ts\n  const a = Maybe.of(3);\n  const b = Maybe.of(3);\n  const c = Maybe.of(null);\n  const d = Maybe.nothing();\n\n  Maybe.equals(a, b); // true\n  Maybe.equals(a, c); // false\n  Maybe.equals(c, d); // true\n  ```\n\n  @param mb A `maybe` to compare to.\n  @param ma A `maybe` instance to check.\n */\nexport function equals<T>(mb: Maybe<T>, ma: Maybe<T>): boolean;\nexport function equals<T>(mb: Maybe<T>): (ma: Maybe<T>) => boolean;\nexport function equals<T>(mb: Maybe<T>, ma?: Maybe<T>): boolean | ((a: Maybe<T>) => boolean) {\n  return ma !== undefined\n    ? ma.match({\n        Just: aVal => mb.isJust() && mb.unsafelyUnwrap() === aVal,\n        Nothing: () => isNothing(mb),\n      })\n    : (maybeA: Maybe<T>) =>\n        maybeA.match({\n          Nothing: () => isNothing(mb),\n          Just: aVal => mb.isJust() && mb.unsafelyUnwrap() === aVal,\n        });\n}\n\n/**\n  Allows you to *apply* (thus `ap`) a value to a function without having to\n  take either out of the context of their `Maybe`s. This does mean that the\n  transforming function is itself within a `Maybe`, which can be hard to grok\n  at first but lets you do some very elegant things. For example, `ap` allows\n  you to this:\n\n  ```ts\n  import { just, nothing } from 'true-myth/maybe';\n\n  const one = just(1);\n  const five = just(5);\n  const none = nothing();\n\n  const add = (a: number) => (b: number) => a + b;\n  const maybeAdd = just(add);\n\n  maybeAdd.ap(one).ap(five); // Just(6)\n  maybeAdd.ap(one).ap(none); // Nothing\n  maybeAdd.ap(none).ap(five) // Nothing\n  ```\n\n  Without `Maybe.ap`, you'd need to do something like a nested `Maybe.match`:\n\n  ```ts\n  import { just, nothing } from 'true-myth/maybe';\n\n  const one = just(1);\n  const five = just(5);\n  const none = nothing();\n\n  one.match({\n    Just: n => five.match({\n      Just: o => just(n + o),\n      Nothing: () => nothing(),\n    }),\n    Nothing: ()  => nothing(),\n  }); // Just(6)\n\n  one.match({\n    Just: n => none.match({\n      Just: o => just(n + o),\n      Nothing: () => nothing(),\n    }),\n    Nothing: ()  => nothing(),\n  }); // Nothing\n\n  none.match({\n    Just: n => five.match({\n      Just: o => just(n + o),\n      Nothing: () => nothing(),\n    }),\n    Nothing: ()  => nothing(),\n  }); // Nothing\n  ```\n\n  And this kind of thing comes up quite often once you're using `Maybe` to\n  handle optionality throughout your application.\n\n  For another example, imagine you need to compare the equality of two\n  ImmutableJS data structures, where a `===` comparison won't work. With `ap`,\n  that's as simple as this:\n\n  ```ts\n  import Maybe from 'true-myth/maybe';\n  import Immutable from 'immutable';\n  import { curry } from 'lodash'\n\n  const is = curry(Immutable.is);\n\n  const x = Maybe.of(Immutable.Set.of(1, 2, 3));\n  const y = Maybe.of(Immutable.Set.of(2, 3, 4));\n\n  Maybe.of(is).ap(x).ap(y); // Just(false)\n  ```\n\n  Without `ap`, we're back to that gnarly nested `match`:\n\n  ```ts\n   * import Maybe, { just, nothing } from 'true-myth/maybe';\n  import Immutable from 'immutable';\n  import { curry } from 'lodash'\n\n  const is = curry(Immutable.is);\n\n  const x = Maybe.of(Immutable.Set.of(1, 2, 3));\n  const y = Maybe.of(Immutable.Set.of(2, 3, 4));\n\n  x.match({\n    Just: iX => y.match({\n      Just: iY => Maybe.just(Immutable.is(iX, iY)),\n      Nothing: () => Maybe.nothing(),\n    })\n    Nothing: () => Maybe.nothing(),\n  }); // Just(false)\n  ```\n\n  In summary: anywhere you have two `Maybe` instances and need to perform an\n  operation that uses both of them, `ap` is your friend.\n\n  Two things to note, both regarding *currying*:\n\n  1.  All functions passed to `ap` must be curried. That is, they must be of the\n      form (for add) `(a: number) => (b: number) => a + b`, *not* the more usual\n      `(a: number, b: number) => a + b` you see in JavaScript more generally.\n\n      For convenience, you may want to look at Lodash's `_.curry` or Ramda's\n      `R.curry`, which allow you to create curried versions of functions\n      whenever you want:\n\n      ```\n      import Maybe from 'true-myth/maybe';\n      import { curry } from 'lodash';\n\n      const normalAdd = (a: number, b: number) => a + b;\n      const curriedAdd = curry(normalAdd); // (a: number) => (b: number) => a + b;\n\n      Maybe.of(curriedAdd).ap(Maybe.of(1)).ap(Maybe.of(5)); // Just(6)\n      ```\n\n  2.  You will need to call `ap` as many times as there are arguments to the\n      function you're dealing with. So in the case of `add`, which has the\n      \"arity\" (function argument count) of 2 (`a` and `b`), you'll need to call\n      `ap` twice: once for `a`, and once for `b`. To see why, let's look at what\n      the result in each phase is:\n\n      ```ts\n      const add = (a: number) => (b: number) => a + b;\n\n      const maybeAdd = Maybe.of(add); // Just((a: number) => (b: number) => a + b)\n      const maybeAdd1 = maybeAdd.ap(Maybe.of(1)); // Just((b: number) => 1 + b)\n      const final = maybeAdd1.ap(Maybe.of(3)); // Just(4)\n      ```\n\n      So for `toString`, which just takes a single argument, you would only need\n      to call `ap` once.\n\n      ```ts\n      const toStr = (v: { toString(): string }) => v.toString();\n      Maybe.of(toStr).ap(12); // Just(\"12\")\n      ```\n\n  One other scenario which doesn't come up *quite* as often but is conceivable\n  is where you have something that may or may not actually construct a function\n  for handling a specific `Maybe` scenario. In that case, you can wrap the\n  possibly-present in `ap` and then wrap the values to apply to the function to\n  in `Maybe` themselves.\n\n  **Aside:** `ap` is not named `apply` because of the overlap with JavaScript's\n  existing [`apply`] function – and although strictly speaking, there isn't any\n  direct overlap (`Maybe.apply` and `Function.prototype.apply` don't intersect\n  at all) it's useful to have a different name to avoid implying that they're\n  the same.\n\n  [`apply`]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply\n\n  @param maybeFn maybe a function from T to U\n  @param maybe maybe a T to apply to `fn`\n */\nexport function ap<T, U>(maybeFn: Maybe<(t: T) => U>, maybe: Maybe<T>): Maybe<U>;\nexport function ap<T, U>(maybeFn: Maybe<(t: T) => U>): (maybe: Maybe<T>) => Maybe<U>;\nexport function ap<T, U>(\n  maybeFn: Maybe<(val: T) => U>,\n  maybe?: Maybe<T>\n): Maybe<U> | ((val: Maybe<T>) => Maybe<U>) {\n  const op = (m: Maybe<T>) =>\n    m.match({\n      Just: val => maybeFn.map(fn => fn(val)),\n      Nothing: () => Maybe.nothing<U>(),\n    });\n\n  return curry1(op, maybe);\n}\n\n/**\n  Determine whether an item is an instance of `Just` or `Nothing`.\n\n  @param item The item to check.\n */\nexport function isInstance<T = any>(item: any): item is Maybe<T> {\n  return item instanceof Just || item instanceof Nothing;\n}\n\ntype Predicate<T> = (element: T, index: number, array: T[]) => boolean;\n\n// NOTE: documentation is lightly adapted from the MDN and TypeScript docs for\n// `Array.prototype.find`.\n/**\n  Safely search for an element in an array.\n  \n  This function behaves like `Array.prototype.find`, but returns `Maybe<T>`\n  instead of `T | undefined`.\n  \n  ## Examples\n\n  The basic form is:\n\n  ```ts\n  import Maybe from 'true-myth/maybe';\n\n  let array = [1, 2, 3];\n  Maybe.find(v => v > 1, array); // Just(2)\n  Maybe.find(v => v < 1, array); // Nothing\n  ```\n\n  The function is curried so you can use it in a functional chain. For example\n  (leaving aside error handling on a bad response for simplicity), suppose the\n  url `https://arrays.example.com` returned a JSON payload with the type\n  `Array<{ count: number, name: string }>`, and we wanted to get the first\n  of these where `count` was at least 100. We could write this:\n\n  ```ts\n  import Maybe from 'true-myth/maybe';\n\n  type Item = { count: number; name: string };\n  type Response = Array<Item>;\n\n  // curried variant!\n  const findAtLeast100 = Maybe.find(({ count }: Item) => count > 100);\n\n  fetch('https://arrays.example.com')\n    .then(response => response.json() as Response)\n    .then(findAtLeast100)\n    .then(found => {\n      if (found.isJust()) {\n        console.log(`The matching value is ${found.value.name}!`);\n      }\n    });\n  ```\n  \n  @param predicate  A function to execute on each value in the array, returning\n                    `true` when the item in the array matches the condition. The\n                    signature for `predicate` is identical to the signature for\n                    the first argument to `Array.prototype.find`. The function\n                    is called once for each element of the array, in ascending\n                    order, until it finds one where predicate returns true. If\n                    such an element is found, find immediately returns that\n                    element value wrapped in `Just`. Otherwise, `Maybe.find`\n                    returns `Nothing`.\n * @param array     The array to search using the predicate.\n */\nexport function find<T>(predicate: Predicate<T>, array: T[]): Maybe<T>;\nexport function find<T>(predicate: Predicate<T>): (array: T[]) => Maybe<T>;\nexport function find<T>(\n  predicate: Predicate<T>,\n  array?: T[]\n): Maybe<T> | ((array: T[]) => Maybe<T>) {\n  const op = (a: T[]) => Maybe.of(a.find(predicate));\n  return curry1(op, array);\n}\n\n/**\n  Safely get the first item from a list, returning `Just` the first item if the\n  array has at least one item in it, or `Nothing` if it is empty.\n\n  ## Examples\n\n  ```ts\n  let empty = [];\n  Maybe.head(empty); // => Nothing\n\n  let full = [1, 2, 3];\n  Maybe.head(full); // => Just(1)\n  ```\n\n  @param array The array to get the first item from.\n */\nexport function head<T>(array: Array<T | null | undefined>): Maybe<T> {\n  return Maybe.of(array[0]);\n}\n\n/** A convenience alias for `Maybe.head`. */\nexport const first = head;\n\n/**\n  Safely get the last item from a list, returning `Just` the last item if the\n  array has at least one item in it, or `Nothing` if it is empty.\n\n  ## Examples\n\n  ```ts\n  let empty = [];\n  Maybe.last(empty); // => Nothing\n\n  let full = [1, 2, 3];\n  Maybe.last(full); // => Just(3)\n  ```\n\n  @param array The array to get the first item from.\n */\nexport function last<T>(array: Array<T | null | undefined>): Maybe<T> {\n  return Maybe.of(array[array.length - 1]);\n}\n\n/**\n  Convert the arguments to a single `Maybe`. Useful for dealing with arrays of\n  `Maybe`s, via the spread operator.\n\n  ## Examples\n\n  ```ts\n  import Maybe from 'true-myth/maybe';\n\n  let valid = [Maybe.just(2), Maybe.just('three')];\n  Maybe.all(...valid); // => Just([2, 'three']);\n\n  let invalid = [Maybe.just(2), Maybe.nothing<string>()];\n  Maybe.all(...invalid); // => Nothing\n  ```\n\n  ## Note on Spread\n\n  This requires the use of the spread operator because (at least as of\n  TypeScript 3.0), the type inference falls down when attempting to build this\n  same type with an array directly. Moreover, this spread-based approach handles\n  heteregenous arrays; TS *also* fails to infer correctly for anything but\n  homogeneous arrays when using that approach.\n\n  @param maybes The `Maybe`s to resolve to a single `Maybe`.\n */\nexport function all<T extends Array<Maybe<unknown>>>(...maybes: T): All<T> {\n  let result: All<T> = Maybe.just([] as Maybe<unknown>[]) as All<T>;\n  maybes.forEach(maybe => {\n    result = result.andThen(accumulatedMaybes =>\n      maybe.map(m => {\n        accumulatedMaybes.push(m);\n        return accumulatedMaybes;\n      })\n    ) as All<T>;\n  });\n\n  return result;\n}\n\ntype All<T extends Array<Maybe<any>>> = T extends Array<Maybe<infer U>> ? Maybe<Array<U>> : never;\n\n/**\n  Given a tuple of `Maybe`s, return a `Maybe` of the tuple values.\n\n  Given a tuple of type `[Maybe<A>, Maybe<B>]`, the resulting type is\n  `Maybe<[A, B]>`. Works with up to a 5-tuple. (If you're doing more than a\n  5-tuple, what are you doing???)\n\n  ## Examples\n\n  If any of the items in the tuple are `Nothing`, the whole result is `Nothing`.\n  Here, for example, `result` has the type `Maybe<[string, number]>` and will be\n  `Nothing`:\n\n  ```ts\n  import Maybe from 'true-myth/maybe';\n\n  type Tuple = [Maybe<string>, Maybe<number>];\n\n  let invalid: Tuple = [Maybe.just('wat'), Maybe.nothing()];\n  let result = Maybe.tuple(invalid);  // => Nothing\n  ```\n\n  If all of the items in the tuple are `Just`, the result is `Just` wrapping the\n  tuple of the values of the items. Here, for example, `result` again has the\n  type `Maybe<[string, number]>` and will be `Just(['hey', 12]`:\n\n  ```ts\n  import Maybe from 'true-myth/maybe';\n\n  type Tuple = [Maybe<string>, Maybe<number>];\n\n  let valid: Tuple = [Maybe.just('hey'), Maybe.just(12)];\n  let result = Maybe.tuple(valid);  // => Just(['hey', 12])\n  ```\n\n  @param maybes: the tuple of `Maybe`s to convert to a `Maybe` of tuple values.\n */\n// @ts-ignore -- this doesn't type-check, but it is correct!\nexport function tuple<T>(maybes: [Maybe<T>]): Maybe<[T]>;\nexport function tuple<T, U>(maybes: [Maybe<T>, Maybe<U>]): Maybe<[T, U]>;\nexport function tuple<T, U, V>(maybes: [Maybe<T>, Maybe<U>, Maybe<V>]): Maybe<[T, U, V]>;\nexport function tuple<T, U, V, W>(\n  maybes: [Maybe<T>, Maybe<U>, Maybe<V>, Maybe<W>]\n): Maybe<[T, U, V, W]>;\nexport function tuple<T, U, V, W, X>(\n  maybes: [Maybe<T>, Maybe<U>, Maybe<V>, Maybe<W>, Maybe<X>]\n): Maybe<[T, U, V, W, X]> {\n  // @ts-ignore -- this doesn't type-check, but it works correctly.\n  return all(...maybes);\n}\n\n/**\n  Safely extract a key from an object, returning `Just` if the key has a value\n  on the object and `Nothing` if it does not.\n\n  The check is type-safe: you won't even be able to compile if you try to look\n  up a property that TypeScript *knows* doesn't exist on the object.\n\n  ```ts\n  type Person = { name?: string };\n\n  const me: Person = { name: 'Chris' };\n  console.log(Maybe.property('name', me)); // Just('Chris')\n\n  const nobody: Person = {};\n  console.log(Maybe.property('name', nobody)); // Nothing\n  ```\n\n  However, it also works correctly with dictionary types:\n\n  ```ts\n  type Dict<T> = { [key: string]: T };\n\n  const score: Dict<number> = {\n    player1: 0,\n    player2: 1\n  };\n\n  console.log(Maybe.property('player1', score)); // Just(0)\n  console.log(Maybe.property('player2', score)); // Just(1)\n  console.log(Maybe.property('player3', score)); // Nothing\n  ```\n\n  The order of keys is so that it can be partially applied:\n\n  ```ts\n  type Person = { name?: string };\n  \n  const lookupName = Maybe.property('name');\n  \n  const me: Person = { name: 'Chris' };\n  console.log(lookupName(me)); // Just('Chris')\n\n  const nobody: Person = {};\n  console.log(lookupName(nobody)); // Nothing\n  ```\n  \n  @param key The key to pull out of the object.\n  @param obj The object to look up the key from.\n */\nexport function property<T, K extends keyof T>(key: K, obj: T): Maybe<NonNullable<T[K]>>;\nexport function property<T, K extends keyof T>(key: K): (obj: T) => Maybe<NonNullable<T[K]>>;\nexport function property<T, K extends keyof T>(\n  key: K,\n  obj?: T\n): Maybe<NonNullable<T[K]>> | ((obj: T) => Maybe<NonNullable<T[K]>>) {\n  const op = (a: T) => Maybe.of(a[key]) as Maybe<NonNullable<T[K]>>;\n  return curry1(op, obj);\n}\n\n/**\n  Safely extract a key from a Maybe of an object, returning `Just` if the key\n  has a value on the object and `Nothing` if it does not. (Like `Maybe.property`\n  but operating on a `Maybe<T>` rather than directly on a `T`.)\n\n  The check is type-safe: you won't even be able to compile if you try to look\n  up a property that TypeScript *knows* doesn't exist on the object.\n\n  ```ts\n  type Person = { name?: string };\n\n  const me: Maybe<Person> = Maybe.just({ name: 'Chris' });\n  console.log(Maybe.get('name', me)); // Just('Chris')\n\n  const nobody = Maybe.nothing<Person>();\n  console.log(Maybe.get('name', nobody)); // Nothing\n  ```\n\n  However, it also works correctly with dictionary types:\n\n  ```ts\n  type Dict<T> = { [key: string]: T };\n\n  const score: Maybe<Dict<number>> = Maybe.just({\n    player1: 0,\n    player2: 1\n  });\n\n  console.log(Maybe.get('player1', score)); // Just(0)\n  console.log(Maybe.get('player2', score)); // Just(1)\n  console.log(Maybe.get('player3', score)); // Nothing\n  ```\n\n  The order of keys is so that it can be partially applied:\n\n  ```ts\n  type Person = { name?: string };\n  \n  const lookupName = Maybe.get('name');\n  \n  const me: Person = { name: 'Chris' };\n  console.log(lookupName(me)); // Just('Chris')\n\n  const nobody: Person = {};\n  console.log(lookupName(nobody)); // Nothing\n  ```\n  \n  @param key The key to pull out of the object.\n  @param obj The object to look up the key from.\n */\nexport function get<T, K extends keyof T>(key: K, maybeObj: Maybe<T>): Maybe<Required<T>[K]>;\nexport function get<T, K extends keyof T>(key: K): (maybeObj: Maybe<T>) => Maybe<Required<T>[K]>;\nexport function get<T, K extends keyof T>(\n  key: K,\n  maybeObj?: Maybe<T>\n): Maybe<Required<T>[K]> | ((maybeObj: Maybe<T>) => Maybe<Required<T>[K]>) {\n  return curry1(Maybe.andThen(property<T, K>(key)), maybeObj);\n}\n\n/** A value which may (`Just<T>`) or may not (`Nothing`) be present. */\nexport type Maybe<T> = Just<T> | Nothing<T>;\nexport const Maybe = {\n  Variant,\n  Just,\n  Nothing,\n  all,\n  isJust,\n  isNothing,\n  just,\n  nothing,\n  of,\n  find,\n  first,\n  fromNullable,\n  head,\n  last,\n  map,\n  mapOr,\n  mapOrElse,\n  and,\n  andThen,\n  chain,\n  flatMap,\n  or,\n  orElse,\n  unsafelyUnwrap,\n  unsafelyGet,\n  unsafeGet,\n  unwrapOr,\n  getOr,\n  unwrapOrElse,\n  getOrElse,\n  toOkOrErr,\n  toOkOrElseErr,\n  fromResult,\n  toString,\n  tuple,\n  match,\n  cata,\n  equals,\n  ap,\n  isInstance,\n  property,\n  get,\n};\n\nexport default Maybe;\n"]}