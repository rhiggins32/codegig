{"version":3,"file":"result.js","sourceRoot":"./","sources":["result.ts"],"names":[],"mappings":"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","sourcesContent":["/** [[include:doc/result.md]] */\n\n/** (keep typedoc from getting confused by the import) */\nimport Maybe, { isJust, just, nothing } from './maybe';\nimport Unit from './unit';\nimport { _Brand, curry1, isVoid } from './utils';\n\n// So that it doesn't appear unused but can be exported.\n_Brand; // tslint:disable-line:no-unused-expression\n\n/**\n  Discriminant for `Ok` and `Err` variants of `Result` type.\n\n  You can use the discriminant via the `variant` property of `Result` instances\n  if you need to match explicitly on it.\n */\nexport enum Variant {\n  Ok = 'Ok',\n  Err = 'Err',\n}\n\n/** Simply defines the common shape for `Ok` and `Err`. */\nexport interface ResultShape<T, E> {\n  /** Distinguish between the `Ok` and `Err` variants. */\n  readonly variant: Variant;\n\n  /** Method variant for [`Result.isOk`](../modules/_result_.html#isok) */\n  isOk(this: Result<T, E>): this is Ok<T, E>;\n\n  /** Method variant for [`Result.isErr`](../modules/_result_.html#iserr) */\n  isErr(this: Result<T, E>): this is Err<T, E>;\n\n  /** Method variant for [`Result.map`](../modules/_result_.html#map) */\n  map<U>(this: Result<T, E>, mapFn: (t: T) => U): Result<U, E>;\n\n  /** Method variant for [`Result.mapOr`](../modules/_result_.html#mapor) */\n  mapOr<U>(this: Result<T, E>, orU: U, mapFn: (t: T) => U): U;\n\n  /** Method variant for [`Result.mapOrElse`](../modules/_result_.html#maporelse) */\n  mapOrElse<U>(this: Result<T, E>, orElseFn: (err: E) => U, mapFn: (t: T) => U): U;\n\n  /** Method variant for [`Result.match`](../modules/_result_.html#match) */\n  match<U>(this: Result<T, E>, matcher: Matcher<T, E, U>): U;\n\n  /** Method variant for [`Result.mapErr`](../modules/_result_.html#maperr) */\n  mapErr<F>(this: Result<T, E>, mapErrFn: (e: E) => F): Result<T, F>;\n\n  /** Method variant for [`Result.or`](../modules/_result_.html#or) */\n  or<F>(this: Result<T, E>, orResult: Result<T, F>): Result<T, F>;\n\n  /** Method variant for [`Result.orElse`](../modules/_result_.html#orelse) */\n  orElse<F>(this: Result<T, E>, orElseFn: (err: E) => Result<T, F>): Result<T, F>;\n\n  /** Method variant for [`Result.and`](../modules/_result_.html#and) */\n  and<U>(this: Result<T, E>, mAnd: Result<U, E>): Result<U, E>;\n\n  /** Method variant for [`Result.andThen`](../modules/_result_.html#andthen) */\n  andThen<U>(this: Result<T, E>, andThenFn: (t: T) => Result<U, E>): Result<U, E>;\n\n  /** Method variant for [`Result.chain`](../modules/_result_.html#chain) */\n  chain<U>(this: Result<T, E>, chainFn: (t: T) => Result<U, E>): Result<U, E>;\n\n  /** Method variant for [`Result.flatMap`](../modules/_result_.html#flatmap) */\n  flatMap<U>(this: Result<T, E>, chainFn: (t: T) => Result<U, E>): Result<U, E>;\n\n  /** Method variant for [`Result.unwrap`](../modules/_result_.html#unwrap) */\n  unsafelyUnwrap(): T | never;\n\n  /** Method variant for [`Result.unwrapErr`](../modules/_result_.html#unwraperr) */\n  unsafelyUnwrapErr(): E | never;\n\n  /** Method variant for [`Result.unwrapOr`](../modules/_result_.html#unwrapor) */\n  unwrapOr(this: Result<T, E>, defaultValue: T): T;\n\n  /** Method variant for [`Result.unwrapOrElse`](../modules/_result_.html#unwrapOrElse) */\n  unwrapOrElse(this: Result<T, E>, elseFn: (error: E) => T): T;\n\n  /** Method variant for [`Result.toMaybe`](../modules/_result_.html#tomaybe) */\n  toMaybe(this: Result<T, E>): Maybe<T>;\n\n  /** Method variant for [`Result.toString`](../modules/_result_.html#tostring) */\n  toString(this: Result<T, E>): string;\n\n  /** Method variant for [`Result.equals`](../modules/_result_.html#equals) */\n  equals(this: Result<T, E>, comparison: Result<T, E>): boolean;\n\n  /** Method variant for [`Result.ap`](../modules/_result_.html#ap) */\n  ap<A, B>(this: Result<(a: A) => B, E>, r: Result<A, E>): Result<B, E>;\n}\n\n/**\n  An `Ok` instance is the *successful* variant instance of the\n  [`Result`](../modules/_result_.html#result) type, representing a successful\n  outcome from an operation which may fail. For a full discussion, see [the\n  module docs](../modules/_result_.html).\n\n  @typeparam T The type wrapped in this `Ok` variant of `Result`.\n  @typeparam E The type which would be wrapped in an `Err` variant of `Result`.\n */\nexport class Ok<T, E> implements ResultShape<T, E> {\n  /**\n    Unwrap the contained value. A convenience method for functional idioms.\n\n    A common scenario where you might want to use this is in a pipeline of\n    functions:\n\n    ```ts\n    import Result, { Ok } from 'true-myth/result';\n\n    function getLengths(results: Array<Result<string, string>>): Array<number> {\n      return results\n        .filter(Result.isOk)\n        .map(Ok.unwrap)\n        .map(s => s.length);\n    }\n    ```\n   */\n  static unwrap<O>(theOk: Ok<O, any>): O {\n    return theOk.value;\n  }\n\n  /** `Ok` is always [`Variant.Ok`](../enums/_result_.variant#ok). */\n  readonly variant: Variant.Ok = Variant.Ok;\n\n  /** The wrapped value. */\n  readonly value: T;\n\n  /**\n    Create an instance of `Result.Ok` with `new`.\n\n    Note: While you *may* create the `Result` type via normal\n    JavaScript class construction, it is not recommended for the functional\n    style for which the library is intended. Instead, use [`Result.ok`].\n\n    [`Result.ok`]: ../modules/_result_.html#ok\n\n    ```ts\n    // Avoid:\n    const aString = new Result.Ok('characters');\n\n    // Prefer:\n    const aString = Result.ok('characters);\n    ```\n\n    Note that you may explicitly pass `Unit` to the `Ok` constructor to create\n    a `Result<Unit, E>`. However, you may *not* call the `Ok` constructor with\n    `null` or `undefined` to get that result (the type system won't allow you to\n    construct it that way). Instead, for convenience, you can simply call\n    `Result.ok()`, which will construct the type correctly.\n\n    @param value\n    The value to wrap in a `Result.Ok`.\n\n    Note: `null` and `undefined` are allowed by the type signature so that the\n    constructor may `throw` on those rather than constructing a type like\n    `Result<undefined>`.\n\n    @throws If you pass `null`.\n   */\n  constructor(value?: T | null) {\n    if (isVoid(value)) {\n      throw new Error(\n        'Tried to construct `Ok` with `null` or `undefined`. Maybe you want `Maybe.Nothing`?'\n      );\n    }\n\n    this.value = value;\n  }\n\n  /** Method variant for [`Result.isOk`](../modules/_result_.html#isok) */\n  isOk(this: Result<T, E>): this is Ok<T, E> {\n    return true;\n  }\n\n  /** Method variant for [`Result.isErr`](../modules/_result_.html#iserr) */\n  isErr(this: Result<T, E>): this is Err<T, E> {\n    return false;\n  }\n\n  /** Method variant for [`Result.map`](../modules/_result_.html#map) */\n  map<U>(this: Result<T, E>, mapFn: (t: T) => U): Result<U, E> {\n    return map(mapFn, this);\n  }\n\n  /** Method variant for [`Result.mapOr`](../modules/_result_.html#mapor) */\n  mapOr<U>(this: Result<T, E>, orU: U, mapFn: (t: T) => U): U {\n    return mapOr(orU, mapFn, this);\n  }\n\n  /** Method variant for [`Result.mapOrElse`](../modules/_result_.html#maporelse) */\n  mapOrElse<U>(this: Result<T, E>, orElseFn: (err: E) => U, mapFn: (t: T) => U): U {\n    return mapOrElse(orElseFn, mapFn, this);\n  }\n\n  /** Method variant for [`Result.match`](../modules/_result_.html#match) */\n  match<U>(this: Result<T, E>, matcher: Matcher<T, E, U>): U {\n    return match(matcher, this);\n  }\n\n  /** Method variant for [`Result.mapErr`](../modules/_result_.html#maperr) */\n  mapErr<F>(this: Result<T, E>, mapErrFn: (e: E) => F): Result<T, F> {\n    return mapErr(mapErrFn, this);\n  }\n\n  /** Method variant for [`Result.or`](../modules/_result_.html#or) */\n  or<F>(this: Result<T, E>, orResult: Result<T, F>): Result<T, F> {\n    return or(orResult, this);\n  }\n\n  /** Method variant for [`Result.orElse`](../modules/_result_.html#orelse) */\n  orElse<F>(this: Result<T, E>, orElseFn: (err: E) => Result<T, F>): Result<T, F> {\n    return orElse(orElseFn, this);\n  }\n\n  /** Method variant for [`Result.and`](../modules/_result_.html#and) */\n  and<U>(this: Result<T, E>, mAnd: Result<U, E>): Result<U, E> {\n    return and(mAnd, this);\n  }\n\n  /** Method variant for [`Result.andThen`](../modules/_result_.html#andthen) */\n  andThen<U>(this: Result<T, E>, andThenFn: (t: T) => Result<U, E>): Result<U, E> {\n    return andThen(andThenFn, this);\n  }\n\n  /** Method variant for [`Result.chain`](../modules/_result_.html#chain) */\n  chain<U>(this: Result<T, E>, chainFn: (t: T) => Result<U, E>): Result<U, E> {\n    return chain(chainFn, this);\n  }\n\n  /** Method variant for [`Result.flatMap`](../modules/_result_.html#flatmap) */\n  flatMap<U>(this: Result<T, E>, flatMapFn: (t: T) => Result<U, E>): Result<U, E> {\n    return flatMap(flatMapFn, this);\n  }\n\n  /** Method variant for [`Result.unwrap`](../modules/_result_.html#unwrap) */\n  unsafelyUnwrap(): T {\n    return this.value;\n  }\n\n  /** Method variant for [`Result.unwrapErr`](../modules/_result_.html#unwraperr) */\n  unsafelyUnwrapErr(): never {\n    throw new Error('Tried to `unsafelyUnwrapErr` an `Ok`');\n  }\n\n  /** Method variant for [`Result.unwrapOr`](../modules/_result_.html#unwrapor) */\n  unwrapOr(this: Result<T, E>, defaultValue: T): T {\n    return unwrapOr(defaultValue, this);\n  }\n\n  /** Method variant for [`Result.unwrapOrElse`](../modules/_result_.html#unwrapOrElse) */\n  unwrapOrElse(this: Result<T, E>, elseFn: (error: E) => T): T {\n    return unwrapOrElse(elseFn, this);\n  }\n\n  /** Method variant for [`Result.toMaybe`](../modules/_result_.html#tomaybe) */\n  toMaybe(this: Result<T, E>): Maybe<T> {\n    return toMaybe(this);\n  }\n\n  /** Method variant for [`Result.toString`](../modules/_result_.html#tostring) */\n  toString(this: Result<T, E>): string {\n    return toString(this);\n  }\n\n  /** Method variant for [`Result.equals`](../modules/_result_.html#equals) */\n  equals(this: Result<T, E>, comparison: Result<T, E>): boolean {\n    return equals(comparison, this);\n  }\n\n  /** Method variant for [`Result.ap`](../modules/_result_.html#ap) */\n  ap<A, B>(this: Result<(a: A) => B, E>, r: Result<A, E>): Result<B, E> {\n    return ap(this, r);\n  }\n}\n\n/**\n  An `Err` instance is the *failure* variant instance of the\n  [`Result`](../modules/_result_.html#result) type, representing a failure\n  outcome from an operation which may fail. For a full discussion, see [the\n  module docs](../modules/_result_.html).\n\n  @typeparam T The type which would be wrapped in an `Ok` variant of `Result`.\n  @typeparam E The type wrapped in this `Err` variant of `Result`.\n  */\nexport class Err<T, E> implements ResultShape<T, E> {\n  /**\n    Unwrap the contained error . A convenience method for functional idioms.\n\n    A common scenario where you might want to use this is in a pipeline of\n    functions:\n\n    ```ts\n    import Result, { Ok } from 'true-myth/result';\n\n    function getMessages(results: Array<Result<string, Error>>): Array<number> {\n      return maybeStrings\n        .filter(Result.isErr)\n        .map(Err.unwrapErr)\n        .map(e => e.message);\n    }\n    ```\n   */\n  static unwrapErr<F>(theErr: Err<F, any>): F {\n    return theErr.error;\n  }\n\n  /** `Err` is always [`Variant.Err`](../enums/_result_.variant#err). */\n  readonly variant: Variant.Err = Variant.Err;\n\n  /** The wrapped error value. */\n  readonly error: E;\n\n  /**\n    Create an instance of `Result.Err` with `new`.\n\n    Note: While you *may* create the `Result` type via normal\n    JavaScript class construction, it is not recommended for the functional\n    style for which the library is intended. Instead, use [`Result.err`].\n\n    [`Result.err`]: ../modules/_result_.html#err\n\n    ```ts\n    // Avoid:\n    const anErr = new Result.Err('alas, failure');\n\n    // Prefer:\n    const anErr = Result.err('alas, failure');\n    ```\n\n    Note that you may explicitly pass `Unit` to the `Err` constructor to create\n    a `Result<T, Unit>`. However, you may *not* call the `Err` constructor with\n    `null` or `undefined` to get that result (the type system won't allow you to\n    construct it that way). Instead, for convenience, you can simply call\n    `Result.err()`, which will construct the type correctly.\n\n    @param error\n    The value to wrap in a `Result.Err`.\n\n    `Note: null` and `undefined` are allowed by the type signature so that the\n    constructor may `throw` on those rather than constructing a type like\n    `Result<number, undefined>`.\n\n    @throws If you pass `null` or `undefined`.\n   */\n  constructor(error: E | null) {\n    if (isVoid(error)) {\n      throw new Error(\n        'Tried to construct `Err` with `null` or `undefined`. Maybe you want `Maybe.Nothing`?'\n      );\n    }\n\n    this.error = error;\n  }\n\n  /** Method variant for [`Result.isOk`](../modules/_result_.html#isok) */\n  isOk(this: Result<T, E>): this is Ok<T, E> {\n    return false;\n  }\n\n  /** Method variant for [`Result.isErr`](../modules/_result_.html#iserr) */\n  isErr(this: Result<T, E>): this is Err<T, E> {\n    return true;\n  }\n\n  /** Method variant for [`Result.map`](../modules/_result_.html#map) */\n  map<U>(this: Result<T, E>, mapFn: (t: T) => U): Result<U, E> {\n    return map(mapFn, this);\n  }\n\n  /** Method variant for [`Result.mapOr`](../modules/_result_.html#mapor) */\n  mapOr<U>(this: Result<T, E>, orU: U, mapFn: (t: T) => U): U {\n    return mapOr(orU, mapFn, this);\n  }\n\n  /** Method variant for [`Result.mapOrElse`](../modules/_result_.html#maporelse) */\n  mapOrElse<U>(this: Result<T, E>, orElseFn: (err: E) => U, mapFn: (t: T) => U): U {\n    return mapOrElse(orElseFn, mapFn, this);\n  }\n\n  /** Method variant for [`Result.match`](../modules/_result_.html#match) */\n  match<U>(this: Result<T, E>, matchObj: Matcher<T, E, U>): U {\n    return match(matchObj, this);\n  }\n\n  /** Method variant for [`Result.mapErr`](../modules/_result_.html#maperr) */\n  mapErr<F>(this: Result<T, E>, mapErrFn: (e: E) => F): Result<T, F> {\n    return mapErr(mapErrFn, this);\n  }\n\n  /** Method variant for [`Result.or`](../modules/_result_.html#or) */\n  or<F>(this: Result<T, E>, orResult: Result<T, F>): Result<T, F> {\n    return or(orResult, this);\n  }\n\n  /** Method variant for [`Result.orElse`](../modules/_result_.html#orelse) */\n  orElse<F>(this: Result<T, E>, orElseFn: (err: E) => Result<T, F>): Result<T, F> {\n    return orElse(orElseFn, this);\n  }\n\n  /** Method variant for [`Result.and`](../modules/_result_.html#and) */\n  and<U>(this: Result<T, E>, mAnd: Result<U, E>): Result<U, E> {\n    return and(mAnd, this);\n  }\n\n  /** Method variant for [`Result.andThen`](../modules/_result_.html#andthen) */\n  andThen<U>(this: Result<T, E>, andThenFn: (t: T) => Result<U, E>): Result<U, E> {\n    return andThen(andThenFn, this);\n  }\n\n  /** Method variant for [`Result.chain`](../modules/_result_.html#chain) */\n  chain<U>(this: Result<T, E>, chainFn: (t: T) => Result<U, E>): Result<U, E> {\n    return this.andThen(chainFn);\n  }\n\n  /** Method variant for [`Result.flatMap`](../modules/_result_.html#flatmap) */\n  flatMap<U>(this: Result<T, E>, flatMapFn: (t: T) => Result<U, E>): Result<U, E> {\n    return this.andThen(flatMapFn);\n  }\n\n  /** Method variant for [`Result.unsafelyUnwrap`](../modules/_result_.html#unsafelyunwrap) */\n  unsafelyUnwrap(): never {\n    throw new Error('Tried to `unsafelyUnwrap an Err`');\n  }\n\n  /** Method variant for [`Result.unsafelyUnwrapErr`](../modules/_result_.html#unsafelyunwraperr) */\n  unsafelyUnwrapErr(): E {\n    return this.error;\n  }\n\n  /** Method variant for [`Result.unwrapOr`](../modules/_result_.html#unwrapor) */\n  unwrapOr(this: Result<T, E>, defaultValue: T): T {\n    return unwrapOr(defaultValue, this);\n  }\n\n  /** Method variant for [`Result.unwrapOrElse`](../modules/_result_.html#unwraporelse) */\n  unwrapOrElse(this: Result<T, E>, elseFn: (error: E) => T): T {\n    return unwrapOrElse(elseFn, this);\n  }\n\n  /** Method variant for [`Result.toMaybe`](../modules/_result_.html#tomaybe) */\n  toMaybe(this: Result<T, E>): Maybe<T> {\n    return toMaybe(this);\n  }\n\n  /** Method variant for [`Result.toString`](../modules/_result_.html#tostring) */\n  toString(this: Result<T, E>): string {\n    return toString(this);\n  }\n\n  /** Method variant for [`Result.equals`](../modules/_result_.html#equals) */\n  equals(this: Result<T, E>, comparison: Result<T, E>): boolean {\n    return equals(comparison, this);\n  }\n\n  /** Method variant for [`Result.ap`](../modules/_result_.html#ap) */\n  ap<A, B>(this: Result<(a: A) => B, E>, r: Result<A, E>): Result<B, E> {\n    return ap(this, r);\n  }\n}\n\n/**\n  Is this `Result` an `Ok` instance?\n\n  In TypeScript, narrows the type from `Result<T, E>` to `Ok<T, E>`.\n */\nexport function isOk<T, E>(result: Result<T, E>): result is Ok<T, E> {\n  return result.variant === Variant.Ok;\n}\n\n/**\n  Is this `Result` an `Err` instance?\n\n  In TypeScript, narrows the type from `Result<T, E>` to `Err<T, E>`.\n */\nexport function isErr<T, E>(result: Result<T, E>): result is Err<T, E> {\n  return result.variant === Variant.Err;\n}\n\n/**\n  Create an instance of `Result.Ok`.\n\n  If you need to create an instance with a specific type (as you do whenever you\n  are not constructing immediately for a function return or as an argument to a\n  function), you can use a type parameter:\n\n  ```ts\n  const yayNumber = Result.ok<number, string>(12);\n  ```\n\n  Note: `null` is allowed by the type signature so that so that the function\n  may be used to  `throw` on passing `null` rather than constructing a type like\n  `Result<null, string>`. `undefined` is allowed as a convenience method for\n  constructing a `Result<Unit, E>`.\n\n  ```ts\n  const normalResult = Result.ok<number, string>(42);\n  const explicitUnit = Result.ok<Unit, string>(Unit);\n  const implicitUnit = Result.ok<Unit, string>();\n  ```\n\n  In the context of an immediate function return, or an arrow function with a\n  single expression value, you do not have to specify the types, so this can be\n  quite convenient.\n\n  ```ts\n  type SomeData = {\n    //...\n  };\n\n  const isValid = (data: SomeData): boolean => {\n    // true or false...\n  }\n\n  const arrowValidate = (data: SomeData): Result<Unit, string> =>\n    isValid(data) ? Result.ok() : Result.err('something was wrong!');\n\n  function fnValidate(data: someData): Result<Unit, string> {\n    return isValid(data) ? Result.ok() : Result.err('something was wrong');\n  }\n  ```\n\n  @typeparam T The type of the item contained in the `Result`.\n  @param value The value to wrap in a `Result.Ok`.\n */\nexport function ok<T, E>(): Result<Unit, E>;\nexport function ok<T, E>(value: T): Result<T, E>;\nexport function ok<T, E>(value?: T): Result<Unit, E> | Result<T, E> {\n  return value === undefined ? new Ok(Unit) : new Ok(value);\n}\n\n/** `Result.of` is an alias for `Result.ok`. */\nexport const of = ok;\n\n/**\n  Create an instance of `Result.Error`.\n\n  If you need to create an instance with a specific type (as you do whenever you\n  are not constructing immediately for a function return or as an argument to a\n  function), you can use a type parameter:\n\n  ```ts\n  const notString = Result.err<number, string>('something went wrong');\n  ```\n\n  Note: `null` is allowed by the type signature so that so that the function\n  may be used to  `throw` on passing `null` rather than constructing a type like\n  `Result<null, string>`. `undefined` is allowed as a convenience method for\n  constructing a `Result<Unit, E>`.\n\n  ```ts\n  const normalResult = Result.err<number, string>('oh no');\n  const explicitUnit = Result.err<number, Unit>(Unit);\n  const implicitUnit = Result.err<number, Unit>();\n  ```\n\n  In the context of an immediate function return, or an arrow function with a\n  single expression value, you do not have to specify the types, so this can be\n  quite convenient.\n\n  ```ts\n  type SomeData = {\n    //...\n  };\n\n  const isValid = (data: SomeData): boolean => {\n    // true or false...\n  }\n\n  const arrowValidate = (data: SomeData): Result<number, Unit> =>\n    isValid(data) ? Result.ok(42) : Result.err();\n\n  function fnValidate(data: someData): Result<number, Unit> {\n    return isValid(data) ? Result.ok(42) : Result.err();\n  }\n  ```\n\n  @typeparam T The type of the item contained in the `Result`.\n  @param E The error value to wrap in a `Result.Err`.\n */\nexport function err<T, E>(): Result<T, Unit>;\nexport function err<T, E>(error: E): Result<T, E>;\nexport function err<T, E>(error?: E): Result<T, Unit> | Result<T, E> {\n  return isVoid(error) ? new Err(Unit) : new Err(error);\n}\n\n/**\n  Execute the provided callback, wrapping the return value in `Result.Ok` or\n  `Result.Err(error)` if there is an exception.\n\n  ```ts\n  const aSuccessfulOperation = () => 2 + 2;\n\n  const anOkResult = Result.tryOr('Oh noes!!1', () => {\n    aSuccessfulOperation()\n  }); // => Ok(4)\n\n  const thisOperationThrows = () => throw new Error('Bummer');\n\n  const anErrResult = Result.tryOr('Oh noes!!1', () => {\n    thisOperationThrows();\n  }); // => Err('Oh noes!!1')\n ```\n\n  @param error The error value in case of an exception\n  @param callback The callback to try executing\n */\nexport function tryOr<T, E>(error: E, callback: () => T): Result<T, E>;\nexport function tryOr<T, E>(error: E): (callback: () => T) => Result<T, E>;\nexport function tryOr<T, E>(\n  error: E,\n  callback?: () => T\n): Result<T, E> | ((callback: () => T) => Result<T, E>) {\n  const op = (cb: () => T) => {\n    try {\n      return Result.ok<T, E>(cb());\n    } catch {\n      return Result.err<T, E>(error);\n    }\n  };\n\n  return curry1(op, callback);\n}\n\n/**\n  Execute the provided callback, wrapping the return value in `Result.Ok`.\n  If there is an exception, return a `Result.Err` of whatever the `onError`\n  function returns.\n\n  ```ts\n  const aSuccessfulOperation = () => 2 + 2;\n\n  const anOkResult = Result.tryOrElse(\n    (e) => e,\n    aSuccessfulOperation\n  ); // => Ok(4)\n\n  const thisOperationThrows = () => throw 'Bummer'\n\n  const anErrResult = Result.tryOrElse((e) => e, () => {\n    thisOperationThrows();\n  }); // => Err('Bummer')\n ```\n\n  @param onError A function that takes `e` exception and returns what will\n  be wrapped in a `Result.Err`\n  @param callback The callback to try executing\n */\nexport function tryOrElse<T, E>(onError: (e: unknown) => E, callback: () => T): Result<T, E>;\nexport function tryOrElse<T, E>(onError: (e: unknown) => E): (callback: () => T) => Result<T, E>;\nexport function tryOrElse<T, E>(\n  onError: (e: unknown) => E,\n  callback?: () => T\n): Result<T, E> | ((callback: () => T) => Result<T, E>) {\n  const op = (cb: () => T) => {\n    try {\n      return Result.ok<T, E>(cb());\n    } catch (e) {\n      return Result.err<T, E>(onError(e));\n    }\n  };\n\n  return curry1(op, callback);\n}\n\n/**\n  Map over a `Result` instance: apply the function to the wrapped value if the\n  instance is `Ok`, and return the wrapped error value wrapped as a new `Err` of\n  the correct type (`Result<U, E>`) if the instance is `Err`.\n\n  `Result.map` works a lot like `Array.prototype.map`, but with one important\n  difference. Both `Result` and `Array` are containers for other kinds of items,\n  but where `Array.prototype.map` has 0 to _n_ items, a `Result` always has\n  exactly one item, which is *either* a success or an error instance.\n\n  Where `Array.prototype.map` will apply the mapping function to every item in\n  the array (if there are any), `Result.map` will only apply the mapping\n  function to the (single) element if an `Ok` instance, if there is one.\n\n  If you have no items in an array of\n  numbers named `foo` and call `foo.map(x => x + 1)`, you'll still some have an\n  array with nothing in it. But if you have any items in the array (`[2, 3]`),\n  and you call `foo.map(x => x + 1)` on it, you'll get a new array with each of\n  those items inside the array \"container\" transformed (`[3, 4]`).\n\n  With `Result.map`, the `Err` variant is treated *by the `map` function* kind\n  of the same way as the empty array case: it's just ignored, and you get back a\n  new `Result` that is still just the same `Err` instance. But if you have an\n  `Ok` variant, the map function is applied to it, and you get back a new\n  `Result` with the value transformed, and still wrapped in an `Ok`.\n\n  #### Examples\n\n  ```ts\n  import { ok, err, map, toString } from 'true-myth/result';\n  const double = n => n * 2;\n\n  const anOk = ok(12);\n  const mappedOk = map(double, anOk);\n  console.log(toString(mappedOk)); // Ok(24)\n\n  const anErr = err(\"nothing here!\");\n  const mappedErr = map(double, anErr);\n  console.log(toString(mappedOk)); // Err(nothing here!)\n  ```\n\n  @typeparam T  The type of the value wrapped in an `Ok` instance, and taken as\n                the argument to the `mapFn`.\n  @typeparam U  The type of the value wrapped in the new `Ok` instance after\n                applying `mapFn`, that is, the type returned by `mapFn`.\n  @typeparam E  The type of the value wrapped in an `Err` instance.\n  @param mapFn  The function to apply the value to if `result` is `Ok`.\n  @param result The `Result` instance to map over.\n  @returns      A new `Result` with the result of applying `mapFn` to the value\n                in an `Ok`, or else the original `Err` value wrapped in the new\n                instance.\n */\nexport function map<T, U, E>(mapFn: (t: T) => U, result: Result<T, E>): Result<U, E>;\nexport function map<T, U, E>(mapFn: (t: T) => U): (result: Result<T, E>) => Result<U, E>;\nexport function map<T, U, E>(\n  mapFn: (t: T) => U,\n  result?: Result<T, E>\n): Result<U, E> | ((result: Result<T, E>) => Result<U, E>) {\n  const op = (r: Result<T, E>) => (isOk(r) ? ok(mapFn(r.value)) : r) as Result<U, E>;\n  return curry1(op, result);\n}\n\n/**\n  Map over a `Result` instance as in [`map`](#map) and get out the value\n  if `result` is an `Ok`, or return a default value if `result` is an `Err`.\n\n  #### Examples\n\n  ```ts\n  import { ok, err, mapOr } from 'true-myth/result';\n\n  const length = (s: string) => s.length;\n\n  const anOkString = ok('a string');\n  const theStringLength = mapOr(0, anOkString);\n  console.log(theStringLength);  // 8\n\n  const anErr = err('uh oh');\n  const anErrMapped = mapOr(0, anErr);\n  console.log(anErrMapped);  // 0\n  ```\n\n  @param orU The default value to use if `result` is an `Err`.\n  @param mapFn The function to apply the value to if `result` is an `Ok`.\n  @param result The `Result` instance to map over.\n */\nexport function mapOr<T, U, E>(orU: U, mapFn: (t: T) => U, result: Result<T, E>): U;\nexport function mapOr<T, U, E>(orU: U, mapFn: (t: T) => U): (result: Result<T, E>) => U;\nexport function mapOr<T, U, E>(orU: U): (mapFn: (t: T) => U) => (result: Result<T, E>) => U;\nexport function mapOr<T, U, E>(\n  orU: U,\n  mapFn?: (t: T) => U,\n  result?: Result<T, E>\n): U | ((result: Result<T, E>) => U) | ((mapFn: (t: T) => U) => (result: Result<T, E>) => U) {\n  function fullOp(fn: (t: T) => U, r: Result<T, E>): U {\n    return isOk(r) ? fn(r.value) : orU;\n  }\n\n  function partialOp(fn: (t: T) => U): (maybe: Result<T, E>) => U;\n  function partialOp(fn: (t: T) => U, curriedResult: Result<T, E>): U;\n  function partialOp(\n    fn: (t: T) => U,\n    curriedResult?: Result<T, E>\n  ): U | ((maybe: Result<T, E>) => U) {\n    return curriedResult !== undefined\n      ? fullOp(fn, curriedResult)\n      : (extraCurriedResult: Result<T, E>) => fullOp(fn, extraCurriedResult);\n  }\n\n  return mapFn === undefined\n    ? partialOp\n    : result === undefined\n      ? partialOp(mapFn)\n      : partialOp(mapFn, result);\n}\n\n/**\n  Map over a `Result` instance as in [`map`](#map) and get out the value if\n  `result` is `Ok`, or apply a function (`orElseFn`) to the value wrapped in\n  the `Err` to get a default value.\n\n  Like [`mapOr`](#mapor) but using a function to transform the error into a\n  usable value instead of simply using a default value.\n\n  #### Examples\n\n  ```ts\n  import { ok, err, mapOrElse } from 'true-myth/result';\n\n  const summarize = (s: string) => `The response was: '${s}'`;\n  const getReason = (err: { code: number, reason: string }) => err.reason;\n\n  const okResponse = ok(\"Things are grand here.\");\n  const mappedOkAndUnwrapped = mapOrElse(getReason, summarize, okResponse);\n  console.log(mappedOkAndUnwrapped);  // The response was: 'Things are grand here.'\n\n  const errResponse = err({ code: 500, reason: 'Nothing at this endpoint!' });\n  const mappedErrAndUnwrapped = mapOrElse(getReason, summarize, errResponse);\n  console.log(mappedErrAndUnwrapped);  // Nothing at this endpoint!\n  ```\n\n  @typeparam T    The type of the wrapped `Ok` value.\n  @typeparam U    The type of the resulting value from applying `mapFn` to the\n                  `Ok` value or `orElseFn` to the `Err` value.\n  @typeparam E    The type of the wrapped `Err` value.\n  @param orElseFn The function to apply to the wrapped `Err` value to get a\n                  usable value if `result` is an `Err`.\n  @param mapFn    The function to apply to the wrapped `Ok` value if `result` is\n                  an `Ok`.\n  @param result   The `Result` instance to map over.\n */\nexport function mapOrElse<T, U, E>(\n  orElseFn: (err: E) => U,\n  mapFn: (t: T) => U,\n  result: Result<T, E>\n): U;\nexport function mapOrElse<T, U, E>(\n  orElseFn: (err: E) => U,\n  mapFn: (t: T) => U\n): (result: Result<T, E>) => U;\nexport function mapOrElse<T, U, E>(\n  orElseFn: (err: E) => U\n): (mapFn: (t: T) => U) => (result: Result<T, E>) => U;\nexport function mapOrElse<T, U, E>(\n  orElseFn: (err: E) => U,\n  mapFn?: (t: T) => U,\n  result?: Result<T, E>\n): U | ((result: Result<T, E>) => U) | ((mapFn: (t: T) => U) => (result: Result<T, E>) => U) {\n  function fullOp(fn: (t: T) => U, r: Result<T, E>) {\n    return isOk(r) ? fn(r.value) : orElseFn(r.error);\n  }\n\n  function partialOp(fn: (t: T) => U): (maybe: Result<T, E>) => U;\n  function partialOp(fn: (t: T) => U, curriedResult: Result<T, E>): U;\n  function partialOp(\n    fn: (t: T) => U,\n    curriedResult?: Result<T, E>\n  ): U | ((maybe: Result<T, E>) => U) {\n    return curriedResult !== undefined\n      ? fullOp(fn, curriedResult)\n      : (extraCurriedResult: Result<T, E>) => fullOp(fn, extraCurriedResult);\n  }\n\n  return mapFn === undefined\n    ? partialOp\n    : result === undefined\n      ? partialOp(mapFn)\n      : partialOp(mapFn, result);\n}\n\n/**\n  Map over a `Result`, exactly as in [`map`](#map), but operating on the value\n  wrapped in an `Err` instead of the value wrapped in the `Ok`. This is handy\n  for when you need to line up a bunch of different types of errors, or if you\n  need an error of one shape to be in a different shape to use somewhere else in\n  your codebase.\n\n  #### Examples\n\n  ```ts\n  import { ok, err, mapErr, toString } from 'true-myth/result';\n\n  const reason = (err: { code: number, reason: string }) => err.reason;\n\n  const anOk = ok(12);\n  const mappedOk = mapErr(reason, anOk);\n  console.log(toString(mappedOk));  // Ok(12)\n\n  const anErr = err({ code: 101, reason: 'bad file' });\n  const mappedErr = mapErr(reason, anErr);\n  console.log(toString(mappedErr));  // Err(bad file)\n  ```\n\n  @typeparam T    The type of the value wrapped in the `Ok` of the `Result`.\n  @typeparam E    The type of the value wrapped in the `Err` of the `Result`.\n  @typeparam F    The type of the value wrapped in the `Err` of a new `Result`,\n                  returned by the `mapErrFn`.\n  @param mapErrFn The function to apply to the value wrapped in `Err` if `result` is an `Err`.\n  @param result   The `Result` instance to map over an error case for.\n */\nexport function mapErr<T, E, F>(mapErrFn: (e: E) => F, result: Result<T, E>): Result<T, F>;\nexport function mapErr<T, E, F>(mapErrFn: (e: E) => F): (result: Result<T, E>) => Result<T, F>;\nexport function mapErr<T, E, F>(\n  mapErrFn: (e: E) => F,\n  result?: Result<T, E>\n): Result<T, F> | ((result: Result<T, E>) => Result<T, F>) {\n  const op = (r: Result<T, E>) => (isOk(r) ? r : err(mapErrFn(r.error))) as Result<T, F>;\n  return curry1(op, result);\n}\n\n/**\n  You can think of this like a short-circuiting logical \"and\" operation on a\n  `Result` type. If `result` is `Ok`, then the result is the `andResult`. If\n  `result` is `Err`, the result is the `Err`.\n\n  This is useful when you have another `Result` value you want to provide if\n  and *only if* you have an `Ok` – that is, when you need to make sure that if you\n  `Err`, whatever else you're handing a `Result` to *also* gets that `Err`.\n\n  Notice that, unlike in [`map`](#map) or its variants, the original `result` is\n  not involved in constructing the new `Result`.\n\n  #### Examples\n\n  ```ts\n  import { and, ok, err, toString } from 'true-myth/result';\n\n  const okA = ok('A');\n  const okB = ok('B');\n  const anErr = err({ so: 'bad' });\n\n  console.log(toString(and(okB, okA)));  // Ok(B)\n  console.log(toString(and(okB, anErr)));  // Err([object Object])\n  console.log(toString(and(anErr, okA)));  // Err([object Object])\n  console.log(toString(and(anErr, anErr)));  // Err([object Object])\n  ```\n\n  @typeparam T     The type of the value wrapped in the `Ok` of the `Result`.\n  @typeparam U     The type of the value wrapped in the `Ok` of the `andResult`,\n                   i.e. the success type of the `Result` present if the checked\n                   `Result` is `Ok`.\n  @typeparam E     The type of the value wrapped in the `Err` of the `Result`.\n  @param andResult The `Result` instance to return if `result` is `Err`.\n  @param result    The `Result` instance to check.\n */\nexport function and<T, U, E>(andResult: Result<U, E>, result: Result<T, E>): Result<U, E>;\nexport function and<T, U, E>(andResult: Result<U, E>): (result: Result<T, E>) => Result<U, E>;\nexport function and<T, U, E>(\n  andResult: Result<U, E>,\n  result?: Result<T, E>\n): Result<U, E> | ((result: Result<T, E>) => Result<U, E>) {\n  const op = (r: Result<T, E>) => (isOk(r) ? andResult : (r as Err<any, E>));\n  return curry1(op, result);\n}\n\n/**\n  Apply a function to the wrapped value if `Ok` and return a new `Ok`\n  containing the resulting value; or if it is `Err` return it unmodified.\n\n  This differs from `map` in that `thenFn` returns another `Result`. You can use\n  `andThen` to combine two functions which *both* create a `Result` from an\n  unwrapped type.\n\n  You may find the `.then` method on an ES6 `Promise` helpful for comparison: if\n  you have a `Promise`, you can pass its `then` method a callback which\n  returns another `Promise`, and the result will not be a *nested* promise, but\n  a single `Promise`. The difference is that `Promise#then` unwraps *all*\n  layers to only ever return a single `Promise` value, whereas `Result.andThen`\n  will not unwrap nested `Result`s.\n\n  This is also commonly known as (and therefore aliased as) [`flatMap`] or\n  [`chain`]. It is sometimes also known as `bind`, but *not* aliased as such\n  because [`bind` already means something in JavaScript][bind].\n\n  [`flatMap`]: #flatmap\n  [`chain`]: #chain\n  [bind]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\n\n  #### Examples\n\n  ```ts\n  import { ok, err, andThen, toString } from 'true-myth/result';\n\n  const toLengthAsResult = (s: string) => ok(s.length);\n\n  const anOk = ok('just a string');\n  const lengthAsResult = andThen(toLengthAsResult, anOk);\n  console.log(toString(lengthAsResult));  // Ok(13)\n\n  const anErr = err(['srsly', 'whatever']);\n  const notLengthAsResult = andThen(toLengthAsResult, anErr);\n  console.log(toString(notLengthAsResult));  // Err(srsly,whatever)\n  ```\n\n  @typeparam T   The type of the value wrapped in the `Ok` of the `Result`.\n  @typeparam U   The type of the value wrapped in the `Ok` of the `Result`\n                 returned by the `thenFn`.\n  @typeparam E   The type of the value wrapped in the `Err` of the `Result`.\n  @param thenFn  The function to apply to the wrapped `T` if `maybe` is `Just`.\n  @param result  The `Maybe` to evaluate and possibly apply a function to.\n */\nexport function andThen<T, U, E>(\n  thenFn: (t: T) => Result<U, E>,\n  result: Result<T, E>\n): Result<U, E>;\nexport function andThen<T, U, E>(\n  thenFn: (t: T) => Result<U, E>\n): (result: Result<T, E>) => Result<U, E>;\nexport function andThen<T, U, E>(\n  thenFn: (t: T) => Result<U, E>,\n  result?: Result<T, E>\n): Result<U, E> | ((result: Result<T, E>) => Result<U, E>) {\n  const op = (r: Result<T, E>) => (isOk(r) ? thenFn(r.value) : (r as Err<any, E>));\n  return curry1(op, result);\n}\n\n/** Alias for [`andThen`](#andthen). */\nexport const chain = andThen;\n\n/** Alias for [`andThen`](#andthen). */\nexport const flatMap = andThen;\n\n/**\n  Provide a fallback for a given `Result`. Behaves like a logical `or`: if the\n  `result` value is an `Ok`, returns that `result`; otherwise, returns the\n  `defaultResult` value.\n\n  This is useful when you want to make sure that something which takes a\n  `Result` always ends up getting an `Ok` variant, by supplying a default value\n  for the case that you currently have an `Err`.\n\n  ```ts\n  import { ok, err, Result, or } from 'true-utils/result';\n\n  const okA = ok<string, string>('a');\n  const okB = ok<string, string>('b');\n  const anErr = err<string, string>(':wat:');\n  const anotherErr = err<string, string>(':headdesk:');\n\n  console.log(or(okB, okA).toString());  // Ok(A)\n  console.log(or(anErr, okA).toString());  // Ok(A)\n  console.log(or(okB, anErr).toString());  // Ok(B)\n  console.log(or(anotherErr, anErr).toString());  // Err(:headdesk:)\n  ```\n\n  @typeparam T          The type wrapped in the `Ok` case of `result`.\n  @typeparam E          The type wrapped in the `Err` case of `result`.\n  @typeparam F          The type wrapped in the `Err` case of `defaultResult`.\n  @param defaultResult  The `Result` to use if `result` is an `Err`.\n  @param result         The `Result` instance to check.\n  @returns              `result` if it is an `Ok`, otherwise `defaultResult`.\n */\nexport function or<T, E, F>(defaultResult: Result<T, F>, result: Result<T, E>): Result<T, F>;\nexport function or<T, E, F>(defaultResult: Result<T, F>): (result: Result<T, E>) => Result<T, F>;\nexport function or<T, E, F>(\n  defaultResult: Result<T, F>,\n  result?: Result<T, E>\n): Result<T, F> | ((result: Result<T, E>) => Result<T, F>) {\n  const op = (r: Result<T, E>) => (isOk(r) ? (r as Ok<T, any>) : defaultResult);\n  return curry1(op, result);\n}\n\n/**\n  Like `or`, but using a function to construct the alternative `Result`.\n\n  Sometimes you need to perform an operation using other data in the environment\n  to construct the fallback value. In these situations, you can pass a function\n  (which may be a closure) as the `elseFn` to generate the fallback `Result<T>`.\n  It can then transform the data in the `Err` to something usable as an `Ok`, or\n  generate a new `Err` instance as appropriate.\n\n  Useful for transforming failures to usable data.\n\n  @param elseFn The function to apply to the contents of the `Err` if `result`\n                is an `Err`, to create a new `Result`.\n  @param result The `Result` to use if it is an `Ok`.\n  @returns      The `result` if it is `Ok`, or the `Result` returned by `elseFn`\n                if `result` is an `Err.\n */\nexport function orElse<T, E, F>(\n  elseFn: (err: E) => Result<T, F>,\n  result: Result<T, E>\n): Result<T, F>;\nexport function orElse<T, E, F>(\n  elseFn: (err: E) => Result<T, F>\n): (result: Result<T, E>) => Result<T, F>;\nexport function orElse<T, E, F>(\n  elseFn: (err: E) => Result<T, F>,\n  result?: Result<T, E>\n): Result<T, F> | ((result: Result<T, E>) => Result<T, F>) {\n  const op = (r: Result<T, E>) => (isOk(r) ? (r as Ok<T, any>) : elseFn(r.unsafelyUnwrapErr()));\n  return curry1(op, result);\n}\n\n/**\n  Get the value out of the `Result`.\n\n  Returns the content of an `Ok`, but **throws if the `Result` is `Err`.**\n  Prefer to use [`unwrapOr`](#unwrapor) or [`unwrapOrElse`](#unwraporelse).\n\n  @throws If the `Result` instance is `Nothing`.\n */\nexport function unsafelyUnwrap<T, E>(result: Result<T, E>): T {\n  return result.unsafelyUnwrap();\n}\n\n/** Alias for [`unsafelyUnwrap`](#unsafelyunwrap) */\nexport const unsafelyGet = unsafelyUnwrap;\n\n/** Alias for [`unsafelyUnwrap`](#unsafelyunwrap) */\nexport const unsafeGet = unsafelyUnwrap;\n\n/**\n  Get the error value out of the [`Result`](#result).\n\n  Returns the content of an `Err`, but **throws if the `Result` is `Ok`**.\n  Prefer to use [`unwrapOrElse`](#unwraporelse).\n\n  @param result\n  @throws Error If the `Result` instance is `Nothing`.\n */\nexport function unsafelyUnwrapErr<T, E>(result: Result<T, E>): E {\n  return result.unsafelyUnwrapErr();\n}\n\n/** Alias for [`unsafelyUnwrapErr`](#unsafelyunwraperr) */\nexport const unsafelyGetErr = unsafelyUnwrapErr;\n\n/**\n  Safely get the value out of the `Ok` variant of a [`Result`](#result).\n\n  This is the recommended way to get a value out of a `Result` most of the time.\n\n  ```ts\n  import { ok, err, unwrapOr } from 'true-myth/result';\n\n  const anOk = ok<number, string>(12);\n  console.log(unwrapOr(0, anOk));  // 12\n\n  const anErr = err<number, string>('nooooo');\n  console.log(unwrapOr(0, anErr));  // 0\n  ```\n\n  @typeparam T        The value wrapped in the `Ok`.\n  @typeparam E        The value wrapped in the `Err`.\n  @param defaultValue The value to use if `result` is an `Err`.\n  @param result       The `Result` instance to unwrap if it is an `Ok`.\n  @returns            The content of `result` if it is an `Ok`, otherwise\n                      `defaultValue`.\n */\nexport function unwrapOr<T, E>(defaultValue: T, result: Result<T, E>): T;\nexport function unwrapOr<T, E>(defaultValue: T): (result: Result<T, E>) => T;\nexport function unwrapOr<T, E>(\n  defaultValue: T,\n  result?: Result<T, E>\n): T | ((result: Result<T, E>) => T) {\n  const op = (r: Result<T, E>) => (isOk(r) ? r.value : defaultValue);\n  return curry1(op, result);\n}\n\n/** Alias for [`unwrapOr`](#unwrapor) */\nexport const getOr = unwrapOr;\n\n/**\n  Safely get the value out of a [`Result`](#result) by returning the wrapped\n  value if it is `Ok`, or by applying `orElseFn` to the value in the `Err`.\n\n  This is useful when you need to *generate* a value (e.g. by using current\n  values in the environment – whether preloaded or by local closure) instead of\n  having a single default value available (as in [`unwrapOr`](#unwrapor)).\n\n  ```ts\n  import { ok, err, unwrapOrElse } from 'true-myth/result';\n\n  // You can imagine that someOtherValue might be dynamic.\n  const someOtherValue = 2;\n  const handleErr = (errValue: string) => errValue.length + someOtherValue;\n\n  const anOk = ok<number, string>(42);\n  console.log(unwrapOrElse(handleErr, anOk));  // 42\n\n  const anErr = err<number, string>('oh teh noes');\n  console.log(unwrapOrElse(handleErr, anErr));  // 13\n  ```\n\n  @typeparam T    The value wrapped in the `Ok`.\n  @typeparam E    The value wrapped in the `Err`.\n  @param orElseFn A function applied to the value wrapped in `result` if it is\n                  an `Err`, to generate the final value.\n  @param result   The `result` to unwrap if it is an `Ok`.\n  @returns        The value wrapped in `result` if it is `Ok` or the value\n                  returned by `orElseFn` applied to the value in `Err`.\n */\nexport function unwrapOrElse<T, E>(orElseFn: (error: E) => T, result: Result<T, E>): T;\nexport function unwrapOrElse<T, E>(orElseFn: (error: E) => T): (result: Result<T, E>) => T;\nexport function unwrapOrElse<T, E>(\n  orElseFn: (error: E) => T,\n  result?: Result<T, E>\n): T | ((result: Result<T, E>) => T) {\n  const op = (r: Result<T, E>) => (isOk(r) ? r.value : orElseFn(r.error));\n  return curry1(op, result);\n}\n\n/** Alias for [`unwrapOrElse`](#unwraporelse) */\nexport const getOrElse = unwrapOrElse;\n\n/**\n  Convert a [`Result`](#result) to a [`Maybe`](../modules/_maybe_.html#maybe).\n\n  The converted type will be [`Just`] if the `Result` is [`Ok`] or [`Nothing`]\n  if the `Result` is [`Err`]; the wrapped error value will be discarded.\n\n  [`Just`]: ../classes/_maybe_.just.html\n  [`Nothing`]: ../classes/_maybe_.nothing.html\n  [`Ok`]: ../classes/_result_.ok.html\n  [`Err`]: ../classes/_result_.err.html\n\n  @param result The `Result` to convert to a `Maybe`\n  @returns      `Just` the value in `result` if it is `Ok`; otherwise `Nothing`\n */\nexport function toMaybe<T>(result: Result<T, any>): Maybe<T> {\n  return isOk(result) ? just(result.value) : nothing();\n}\n\n/**\n  Transform a [`Maybe`](../modules/_maybe_.html#maybe) into a [`Result`](#result).\n\n  If the `Maybe` is a [`Just`], its value will be wrapped in the [`Ok`] variant;\n  if it is a [`Nothing`] the `errValue` will be wrapped in the [`Err`] variant.\n\n  [`Just`]: ../classes/_maybe_.just.html\n  [`Nothing`]: ../classes/_maybe_.nothing.html\n  [`Ok`]: ../classes/_result_.ok.html\n  [`Err`]: ../classes/_result_.err.html\n\n  @param errValue A value to wrap in an `Err` if `maybe` is a `Nothing`.\n  @param maybe    The `Maybe` to convert to a `Result`.\n */\nexport function fromMaybe<T, E>(errValue: E, maybe: Maybe<T>): Result<T, E>;\nexport function fromMaybe<T, E>(errValue: E): (maybe: Maybe<T>) => Result<T, E>;\nexport function fromMaybe<T, E>(\n  errValue: E,\n  maybe?: Maybe<T>\n): Result<T, E> | ((maybe: Maybe<T>) => Result<T, E>) {\n  const op = (m: Maybe<T>) => (isJust(m) ? ok<T, E>(Maybe.unsafelyUnwrap(m)) : err<T, E>(errValue));\n  return curry1(op, maybe);\n}\n\n/**\n  Create a `String` representation of a `result` instance.\n\n  An `Ok` instance will be printed as `Ok(<representation of the value>)`, and\n  an `Err` instance will be printed as `Err(<representation of the error>)`,\n  where the representation of the value or error is simply the value or error's\n  own `toString` representation. For example:\n\n                call                |         output\n  --------------------------------- | ----------------------\n  `toString(ok(42))`                | `Ok(42)`\n  `toString(ok([1, 2, 3]))`         | `Ok(1,2,3)`\n  `toString(ok({ an: 'object' }))`  | `Ok([object Object])`n\n  `toString(err(42))`               | `Err(42)`\n  `toString(err([1, 2, 3]))`        | `Err(1,2,3)`\n  `toString(err({ an: 'object' }))` | `Err([object Object])`\n\n  @typeparam T The type of the wrapped value; its own `.toString` will be used\n               to print the interior contents of the `Just` variant.\n  @param maybe The value to convert to a string.\n  @returns     The string representation of the `Maybe`.\n */\nexport const toString = <T, E>(result: Result<T, E>): string => {\n  const body = (isOk(result) ? result.value : result.error).toString();\n  return `${result.variant.toString()}(${body})`;\n};\n\n/** A lightweight object defining how to handle each variant of a Maybe. */\nexport type Matcher<T, E, A> = {\n  Ok: (value: T) => A;\n  Err: (error: E) => A;\n};\n\n/**\n  Performs the same basic functionality as `getOrElse`, but instead of simply\n  unwrapping the value if it is `Ok` and applying a value to generate the same\n  default type if it is `Nothing`, lets you supply functions which may transform\n  the wrapped type if it is `Ok` or get a default value for `Nothing`.\n\n  This is kind of like a poor man's version of pattern matching, which\n  JavaScript currently lacks.\n\n  Instead of code like this:\n\n  ```ts\n  import { Result, isOk, match } from 'true-myth/result';\n\n  const logValue = (mightBeANumber: Result<number, string>) => {\n    console.log(\n      isOk(mightBeANumber)\n        ? unsafelyUnwrap(mightBeANumber).toString()\n        : `There was an error: ${unsafelyGetErr(mightBeANumber)}`\n    );\n  };\n  ```\n\n  ...we can write code like this:\n\n  ```ts\n  import { Result, match } from 'true-myth/result';\n\n  const logValue = (mightBeANumber: Result<number, string>) => {\n    const value = match(\n      {\n        Ok: n => n.toString(),\n        Err: e => `There was an error: ${e}`,\n      },\n      mightBeANumber\n    );\n    console.log(value);\n  };\n  ```\n\n  This is slightly longer to write, but clearer: the more complex the resulting\n  expression, the hairer it is to understand the ternary. Thus, this is\n  especially convenient for times when there is a complex result, e.g. when\n  rendering part of a React component inline in JSX/TSX.\n\n  @param matcher A lightweight object defining what to do in the case of each\n                 variant.\n  @param maybe   The `maybe` instance to check.\n */\nexport function match<T, E, A>(matcher: Matcher<T, E, A>, result: Result<T, E>): A;\nexport function match<T, E, A>(matcher: Matcher<T, E, A>): (result: Result<T, E>) => A;\nexport function match<T, E, A>(\n  matcher: Matcher<T, E, A>,\n  result?: Result<T, E>\n): A | ((result: Result<T, E>) => A) {\n  const op = (r: Result<T, E>) => mapOrElse(matcher.Err, matcher.Ok, r);\n  return curry1(op, result);\n}\n\n/** Alias for [`match`](#match) */\nexport const cata = match;\n\n/**\n  Allows quick triple-equal equality check between the values inside two `result`s\n  without having to unwrap them first.\n\n  ```ts\n  const a = Result.of(3)\n  const b = Result.of(3)\n  const c = Result.of(null)\n  const d = Result.nothing()\n\n  Result.equals(a, b) // true\n  Result.equals(a, c) // false\n  Result.equals(c, d) // true\n  ```\n\n  @param resultB A `maybe` to compare to.\n  @param resultA A `maybe` instance to check.\n */\nexport function equals<T, E>(resultB: Result<T, E>, resultA: Result<T, E>): boolean;\nexport function equals<T, E>(resultB: Result<T, E>): (resultA: Result<T, E>) => boolean;\nexport function equals<T, E>(\n  resultB: Result<T, E>,\n  resultA?: Result<T, E>\n): boolean | ((a: Result<T, E>) => boolean) {\n  return resultA !== undefined\n    ? resultA.match({\n        Err: () => isErr(resultB),\n        Ok: a => isOk(resultB) && resultB.unsafelyUnwrap() === a,\n      })\n    : (curriedResultA: Result<T, E>) =>\n        curriedResultA.match({\n          Err: () => isErr(resultB),\n          Ok: a => isOk(resultB) && resultB.unsafelyUnwrap() === a,\n        });\n}\n\n/**\n  Allows you to *apply* (thus `ap`) a value to a function without having to\n  take either out of the context of their `Result`s. This does mean that the\n  transforming function is itself within a `Result`, which can be hard to grok\n  at first but lets you do some very elegant things. For example, `ap` allows\n  you to do this:\n\n  ```ts\n  import Result from 'true-myth/result';\n\n  const one = Result.ok<number, string>(1);\n  const five = Result.ok<number, string>(5);\n  const whoops = Result.err<number, string>('oh no');\n\n  const add = (a: number) => (b: number) => a + b;\n  const resultAdd = Result.ok<typeof add, string>(add);\n\n  resultAdd.ap(one).ap(five); // Ok(6)\n  resultAdd.ap(one).ap(whoops); // Err('oh no')\n  resultAdd.ap(whoops).ap(five) // Err('oh no')\n  ```\n\n  Without `Result.ap`, you'd need to do something like a nested `Result.match`:\n\n  ```ts\n  import { ok, err } from 'true-myth/result';\n\n  const one = ok<number, string>(1);\n  const five = ok<number, string>(5);\n  const whoops = err<number, string>('oh no');\n\n  one.match({\n    Ok: n => five.match({\n      Ok: o => ok<number, string>(n + o),\n      Err: e => err<number, string>(e),\n    }),\n    Err: e  => err<number, string>(e),\n  }); // Ok(6)\n\n  one.match({\n    Ok: n => whoops.match({\n      Ok: o => ok<number, string>(n + o),\n      Err: e => err<number, string>(e),\n    }),\n    Err: e  => err<number, string>(e),\n  }); // Err('oh no')\n\n  whoops.match({\n    Ok: n => five.match({\n      Ok: o => ok(n + o),\n      Err: e => err(e),\n    }),\n    Err: e  => err(e),\n  }); // Err('oh no')\n  ```\n\n  And this kind of thing comes up quite often once you're using `Maybe` to\n  handle optionality throughout your application.\n\n  For another example, imagine you need to compare the equality of two\n  ImmutableJS data structures, where a `===` comparison won't work. With `ap`,\n  that's as simple as this:\n\n  ```ts\n  import { ok } from 'true-myth/result';\n  import Immutable from 'immutable';\n  import { curry } from 'lodash'\n\n  const is = curry(Immutable.is);\n\n  const x = ok(Immutable.Set.of(1, 2, 3));\n  const y = ok(Immutable.Set.of(2, 3, 4));\n\n  ok(is).ap(x).ap(y); // Ok(false)\n  ```\n\n  Without `ap`, we're back to that gnarly nested `match`:\n\n  ```ts\n   * import Result, { ok, err } from 'true-myth/result';\n  import Immutable from 'immutable';\n  import { curry } from 'lodash'\n\n  const is = curry(Immutable.is);\n\n  const x = ok(Immutable.Set.of(1, 2, 3));\n  const y = ok(Immutable.Set.of(2, 3, 4));\n\n  x.match({\n    Ok: iX => y.match({\n      Ok: iY => Result.of(Immutable.is(iX, iY)),\n      Err: (e) => ok(false),\n    })\n    Err: (e) => ok(false),\n  }); // Ok(false)\n  ```\n\n  In summary: anywhere you have two `Maybe` instances and need to perform an\n  operation that uses both of them, `ap` is your friend.\n\n  Two things to note, both regarding *currying*:\n\n  1.  All functions passed to `ap` must be curried. That is, they must be of the\n      form (for add) `(a: number) => (b: number) => a + b`, *not* the more usual\n      `(a: number, b: number) => a + b` you see in JavaScript more generally.\n\n      For convenience, you may want to look at Lodash's `_.curry` or Ramda's\n      `R.curry`, which allow you to create curried versions of functions\n      whenever you want:\n\n      ```\n      import Result from 'true-myth/result';\n      import { curry } from 'lodash';\n\n      const normalAdd = (a: number, b: number) => a + b;\n      const curriedAdd = curry(normalAdd); // (a: number) => (b: number) => a + b;\n\n      Result.of(curriedAdd).ap(Result.of(1)).ap(Result.of(5)); // Ok(6)\n      ```\n\n  2.  You will need to call `ap` as many times as there are arguments to the\n      function you're dealing with. So in the case of `add`, which has the\n      \"arity\" (function argument count) of 2 (`a` and `b`), you'll need to call\n      `ap` twice: once for `a`, and once for `b`. To see why, let's look at what\n      the result in each phase is:\n\n      ```ts\n      const add = (a: number) => (b: number) => a + b;\n\n      const maybeAdd = Result.of(add); // Ok((a: number) => (b: number) => a + b)\n      const maybeAdd1 = maybeAdd.ap(Result.of(1)); // Ok((b: number) => 1 + b)\n      const final = maybeAdd1.ap(Result.of(3)); // Ok(4)\n      ```\n\n      So for `toString`, which just takes a single argument, you would only need\n      to call `ap` once.\n\n      ```ts\n      const toStr = (v: { toString(): string }) => v.toString();\n      Result.of(toStr).ap(12); // Ok(\"12\")\n      ```\n\n  One other scenario which doesn't come up *quite* as often but is conceivable\n  is where you have something that may or may not actually construct a function\n  for handling a specific `Result` scenario. In that case, you can wrap the\n  possibly-present in `ap` and then wrap the values to apply to the function to\n  in `Result` themselves.\n\n  Because `Result` often requires you to type out the full type parameterization\n  on a regular basis, it's convenient to use TypeScript's `typeof` operator to\n  write out the type of a curried function. For example, if you had a function\n  that simply merged three strings, you might write it like this:\n\n  ```ts\n  import Result from 'true-myth/result';\n  import { curry } from 'lodash';\n\n  const merge3Strs = (a: string, b: string, c: string) => string;\n  const curriedMerge = curry(merge3Strs);\n\n  const fn = Result.ok<typeof curriedMerge, string>(curriedMerge);\n  ```\n\n  The alternative is writing out the full signature long-form:\n\n  ```ts\n  const fn = Result.ok<(a: string) => (b: string) => (c: string) => string, string>(curriedMerge);\n  ```\n\n  **Aside:** `ap` is not named `apply` because of the overlap with JavaScript's\n  existing [`apply`] function – and although strictly speaking, there isn't any\n  direct overlap (`Result.apply` and `Function.prototype.apply` don't intersect\n  at all) it's useful to have a different name to avoid implying that they're\n  the same.\n\n  [`apply`]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply\n\n  @param resultFn result of a function from T to U\n  @param result result of a T to apply to `fn`\n */\nexport function ap<T, U, E>(resultFn: Result<(t: T) => U, E>, result: Result<T, E>): Result<U, E>;\nexport function ap<T, U, E>(\n  resultFn: Result<(t: T) => U, E>\n): (result: Result<T, E>) => Result<U, E>;\nexport function ap<T, U, E>(\n  resultFn: Result<(val: T) => U, E>,\n  result?: Result<T, E>\n): Result<U, E> | ((val: Result<T, E>) => Result<U, E>) {\n  const op = (r: Result<T, E>) =>\n    r.match({\n      Ok: val => resultFn.map(fn => fn(val)),\n      Err: e => Result.err<U, E>(e),\n    });\n\n  return curry1(op, result);\n}\n\n/**\n  Determine whether an item is an instance of `Just` or `Nothing`.\n\n  @param item The item to check.\n */\nexport function isInstance<T = any, E = any>(item: any): item is Result<T, E> {\n  return item instanceof Ok || item instanceof Err;\n}\n\n/**\n  A value which may (`Ok`) or may not (`Err`) be present.\n\n  The behavior of this type is checked by TypeScript at compile time, and bears\n  no runtime overhead other than the very small cost of the container object.\n */\nexport type Result<T, E> = Ok<T, E> | Err<T, E>;\nexport const Result = {\n  Variant,\n  Ok,\n  Err,\n  isOk,\n  isErr,\n  ok,\n  err,\n  tryOr,\n  tryOrElse,\n  map,\n  mapOr,\n  mapOrElse,\n  mapErr,\n  and,\n  andThen,\n  chain,\n  flatMap,\n  or,\n  orElse,\n  unsafelyUnwrap,\n  unsafelyGet,\n  unsafeGet,\n  unsafelyUnwrapErr,\n  unsafelyGetErr,\n  unwrapOr,\n  getOr,\n  unwrapOrElse,\n  getOrElse,\n  toMaybe,\n  fromMaybe,\n  toString,\n  match,\n  cata,\n  equals,\n  ap,\n  isInstance,\n};\n\nexport default Result;\n"]}